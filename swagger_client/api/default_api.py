# coding: utf-8

"""
    API

    ## Welcome  This is a place to put general notes and extra information, for internal use.  To get started designing/documenting this API, select a version on the left. # Title No Description  # noqa: E501

    OpenAPI spec version: 3
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from swagger_client.api_client import ApiClient


class DefaultApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def d_elete_authentication_session(self, **kwargs):  # noqa: E501
        """Delete Session  # noqa: E501

        If you would like to delete (or \"logout\") from a session, call this method with a valid session ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.d_elete_authentication_session(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Body7 body:
        :return: InlineResponse20063
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.d_elete_authentication_session_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.d_elete_authentication_session_with_http_info(**kwargs)  # noqa: E501
            return data

    def d_elete_authentication_session_with_http_info(self, **kwargs):  # noqa: E501
        """Delete Session  # noqa: E501

        If you would like to delete (or \"logout\") from a session, call this method with a valid session ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.d_elete_authentication_session_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Body7 body:
        :return: InlineResponse20063
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method d_elete_authentication_session" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/authentication/session', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20063',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def d_elete_list_list_id(self, list_id, session_id, **kwargs):  # noqa: E501
        """Delete List  # noqa: E501

        Delete a list.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.d_elete_list_list_id(list_id, session_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str list_id: (required)
        :param str session_id: (required)
        :return: InlineResponse401
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.d_elete_list_list_id_with_http_info(list_id, session_id, **kwargs)  # noqa: E501
        else:
            (data) = self.d_elete_list_list_id_with_http_info(list_id, session_id, **kwargs)  # noqa: E501
            return data

    def d_elete_list_list_id_with_http_info(self, list_id, session_id, **kwargs):  # noqa: E501
        """Delete List  # noqa: E501

        Delete a list.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.d_elete_list_list_id_with_http_info(list_id, session_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str list_id: (required)
        :param str session_id: (required)
        :return: InlineResponse401
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['list_id', 'session_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method d_elete_list_list_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'list_id' is set
        if ('list_id' not in params or
                params['list_id'] is None):
            raise ValueError("Missing the required parameter `list_id` when calling `d_elete_list_list_id`")  # noqa: E501
        # verify the required parameter 'session_id' is set
        if ('session_id' not in params or
                params['session_id'] is None):
            raise ValueError("Missing the required parameter `session_id` when calling `d_elete_list_list_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'list_id' in params:
            path_params['list_id'] = params['list_id']  # noqa: E501

        query_params = []
        if 'session_id' in params:
            query_params.append(('session_id', params['session_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/list/{list_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse401',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def d_elete_movie_movie_id_rating(self, movie_id, content_type, **kwargs):  # noqa: E501
        """Delete Rating  # noqa: E501

        Remove your rating for a movie.  A valid session or guest session ID is required. You can read more about how this works [here](#docTextSection:NSZtgz7zptsiLYxXZ).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.d_elete_movie_movie_id_rating(movie_id, content_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int movie_id: (required)
        :param str content_type: (required)
        :param str guest_session_id:
        :param str session_id:
        :return: InlineResponse401
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.d_elete_movie_movie_id_rating_with_http_info(movie_id, content_type, **kwargs)  # noqa: E501
        else:
            (data) = self.d_elete_movie_movie_id_rating_with_http_info(movie_id, content_type, **kwargs)  # noqa: E501
            return data

    def d_elete_movie_movie_id_rating_with_http_info(self, movie_id, content_type, **kwargs):  # noqa: E501
        """Delete Rating  # noqa: E501

        Remove your rating for a movie.  A valid session or guest session ID is required. You can read more about how this works [here](#docTextSection:NSZtgz7zptsiLYxXZ).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.d_elete_movie_movie_id_rating_with_http_info(movie_id, content_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int movie_id: (required)
        :param str content_type: (required)
        :param str guest_session_id:
        :param str session_id:
        :return: InlineResponse401
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['movie_id', 'content_type', 'guest_session_id', 'session_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method d_elete_movie_movie_id_rating" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'movie_id' is set
        if ('movie_id' not in params or
                params['movie_id'] is None):
            raise ValueError("Missing the required parameter `movie_id` when calling `d_elete_movie_movie_id_rating`")  # noqa: E501
        # verify the required parameter 'content_type' is set
        if ('content_type' not in params or
                params['content_type'] is None):
            raise ValueError("Missing the required parameter `content_type` when calling `d_elete_movie_movie_id_rating`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'movie_id' in params:
            path_params['movie_id'] = params['movie_id']  # noqa: E501

        query_params = []
        if 'guest_session_id' in params:
            query_params.append(('guest_session_id', params['guest_session_id']))  # noqa: E501
        if 'session_id' in params:
            query_params.append(('session_id', params['session_id']))  # noqa: E501

        header_params = {}
        if 'content_type' in params:
            header_params['Content-Type'] = params['content_type']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/movie/{movie_id}/rating', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse401',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def d_elete_tv_tv_id_rating(self, tv_id, content_type, **kwargs):  # noqa: E501
        """Delete Rating  # noqa: E501

        Remove your rating for a TV show.  A valid session or guest session ID is required. You can read more about how this works [here](#docTextSection:NSZtgz7zptsiLYxXZ).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.d_elete_tv_tv_id_rating(tv_id, content_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int tv_id: (required)
        :param str content_type: (required)
        :param str guest_session_id:
        :param str session_id:
        :return: InlineResponse401
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.d_elete_tv_tv_id_rating_with_http_info(tv_id, content_type, **kwargs)  # noqa: E501
        else:
            (data) = self.d_elete_tv_tv_id_rating_with_http_info(tv_id, content_type, **kwargs)  # noqa: E501
            return data

    def d_elete_tv_tv_id_rating_with_http_info(self, tv_id, content_type, **kwargs):  # noqa: E501
        """Delete Rating  # noqa: E501

        Remove your rating for a TV show.  A valid session or guest session ID is required. You can read more about how this works [here](#docTextSection:NSZtgz7zptsiLYxXZ).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.d_elete_tv_tv_id_rating_with_http_info(tv_id, content_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int tv_id: (required)
        :param str content_type: (required)
        :param str guest_session_id:
        :param str session_id:
        :return: InlineResponse401
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['tv_id', 'content_type', 'guest_session_id', 'session_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method d_elete_tv_tv_id_rating" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'tv_id' is set
        if ('tv_id' not in params or
                params['tv_id'] is None):
            raise ValueError("Missing the required parameter `tv_id` when calling `d_elete_tv_tv_id_rating`")  # noqa: E501
        # verify the required parameter 'content_type' is set
        if ('content_type' not in params or
                params['content_type'] is None):
            raise ValueError("Missing the required parameter `content_type` when calling `d_elete_tv_tv_id_rating`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'tv_id' in params:
            path_params['tv_id'] = params['tv_id']  # noqa: E501

        query_params = []
        if 'guest_session_id' in params:
            query_params.append(('guest_session_id', params['guest_session_id']))  # noqa: E501
        if 'session_id' in params:
            query_params.append(('session_id', params['session_id']))  # noqa: E501

        header_params = {}
        if 'content_type' in params:
            header_params['Content-Type'] = params['content_type']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/tv/{tv_id}/rating', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse401',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def d_elete_tv_tv_id_season_season_number_episode_episode_number_rating(self, tv_id, season_number, episode_number, content_type, **kwargs):  # noqa: E501
        """Delete Rating  # noqa: E501

        Remove your rating for a TV episode.  A valid session or guest session ID is required. You can read more about how this works [here](#docTextSection:NSZtgz7zptsiLYxXZ).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.d_elete_tv_tv_id_season_season_number_episode_episode_number_rating(tv_id, season_number, episode_number, content_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int tv_id: (required)
        :param int season_number: (required)
        :param int episode_number: (required)
        :param str content_type: (required)
        :param str guest_session_id:
        :param str session_id:
        :return: InlineResponse401
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.d_elete_tv_tv_id_season_season_number_episode_episode_number_rating_with_http_info(tv_id, season_number, episode_number, content_type, **kwargs)  # noqa: E501
        else:
            (data) = self.d_elete_tv_tv_id_season_season_number_episode_episode_number_rating_with_http_info(tv_id, season_number, episode_number, content_type, **kwargs)  # noqa: E501
            return data

    def d_elete_tv_tv_id_season_season_number_episode_episode_number_rating_with_http_info(self, tv_id, season_number, episode_number, content_type, **kwargs):  # noqa: E501
        """Delete Rating  # noqa: E501

        Remove your rating for a TV episode.  A valid session or guest session ID is required. You can read more about how this works [here](#docTextSection:NSZtgz7zptsiLYxXZ).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.d_elete_tv_tv_id_season_season_number_episode_episode_number_rating_with_http_info(tv_id, season_number, episode_number, content_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int tv_id: (required)
        :param int season_number: (required)
        :param int episode_number: (required)
        :param str content_type: (required)
        :param str guest_session_id:
        :param str session_id:
        :return: InlineResponse401
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['tv_id', 'season_number', 'episode_number', 'content_type', 'guest_session_id', 'session_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method d_elete_tv_tv_id_season_season_number_episode_episode_number_rating" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'tv_id' is set
        if ('tv_id' not in params or
                params['tv_id'] is None):
            raise ValueError("Missing the required parameter `tv_id` when calling `d_elete_tv_tv_id_season_season_number_episode_episode_number_rating`")  # noqa: E501
        # verify the required parameter 'season_number' is set
        if ('season_number' not in params or
                params['season_number'] is None):
            raise ValueError("Missing the required parameter `season_number` when calling `d_elete_tv_tv_id_season_season_number_episode_episode_number_rating`")  # noqa: E501
        # verify the required parameter 'episode_number' is set
        if ('episode_number' not in params or
                params['episode_number'] is None):
            raise ValueError("Missing the required parameter `episode_number` when calling `d_elete_tv_tv_id_season_season_number_episode_episode_number_rating`")  # noqa: E501
        # verify the required parameter 'content_type' is set
        if ('content_type' not in params or
                params['content_type'] is None):
            raise ValueError("Missing the required parameter `content_type` when calling `d_elete_tv_tv_id_season_season_number_episode_episode_number_rating`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'tv_id' in params:
            path_params['tv_id'] = params['tv_id']  # noqa: E501
        if 'season_number' in params:
            path_params['season_number'] = params['season_number']  # noqa: E501
        if 'episode_number' in params:
            path_params['episode_number'] = params['episode_number']  # noqa: E501

        query_params = []
        if 'guest_session_id' in params:
            query_params.append(('guest_session_id', params['guest_session_id']))  # noqa: E501
        if 'session_id' in params:
            query_params.append(('session_id', params['session_id']))  # noqa: E501

        header_params = {}
        if 'content_type' in params:
            header_params['Content-Type'] = params['content_type']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/tv/{tv_id}/season/{season_number}/episode/{episode_number}/rating', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse401',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def g_et_account(self, session_id, **kwargs):  # noqa: E501
        """Get Details  # noqa: E501

        Get your account details.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_account(session_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str session_id: (required)
        :return: InlineResponse2003
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.g_et_account_with_http_info(session_id, **kwargs)  # noqa: E501
        else:
            (data) = self.g_et_account_with_http_info(session_id, **kwargs)  # noqa: E501
            return data

    def g_et_account_with_http_info(self, session_id, **kwargs):  # noqa: E501
        """Get Details  # noqa: E501

        Get your account details.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_account_with_http_info(session_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str session_id: (required)
        :return: InlineResponse2003
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['session_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method g_et_account" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'session_id' is set
        if ('session_id' not in params or
                params['session_id'] is None):
            raise ValueError("Missing the required parameter `session_id` when calling `g_et_account`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'session_id' in params:
            query_params.append(('session_id', params['session_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/account', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2003',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def g_et_account_account_id_favorite_movies(self, account_id, session_id, **kwargs):  # noqa: E501
        """Get Favorite Movies  # noqa: E501

        Get the list of your favorite movies.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_account_account_id_favorite_movies(account_id, session_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int account_id: (required)
        :param str session_id: (required)
        :return: InlineResponse2001
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.g_et_account_account_id_favorite_movies_with_http_info(account_id, session_id, **kwargs)  # noqa: E501
        else:
            (data) = self.g_et_account_account_id_favorite_movies_with_http_info(account_id, session_id, **kwargs)  # noqa: E501
            return data

    def g_et_account_account_id_favorite_movies_with_http_info(self, account_id, session_id, **kwargs):  # noqa: E501
        """Get Favorite Movies  # noqa: E501

        Get the list of your favorite movies.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_account_account_id_favorite_movies_with_http_info(account_id, session_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int account_id: (required)
        :param str session_id: (required)
        :return: InlineResponse2001
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id', 'session_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method g_et_account_account_id_favorite_movies" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_id' is set
        if ('account_id' not in params or
                params['account_id'] is None):
            raise ValueError("Missing the required parameter `account_id` when calling `g_et_account_account_id_favorite_movies`")  # noqa: E501
        # verify the required parameter 'session_id' is set
        if ('session_id' not in params or
                params['session_id'] is None):
            raise ValueError("Missing the required parameter `session_id` when calling `g_et_account_account_id_favorite_movies`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'account_id' in params:
            path_params['account_id'] = params['account_id']  # noqa: E501

        query_params = []
        if 'session_id' in params:
            query_params.append(('session_id', params['session_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/account/{account_id}/favorite/movies', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2001',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def g_et_account_account_id_favorite_tv(self, account_id, session_id, **kwargs):  # noqa: E501
        """Get Favorite TV Shows  # noqa: E501

        Get the list of your favorite TV shows.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_account_account_id_favorite_tv(account_id, session_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int account_id: (required)
        :param str session_id: (required)
        :return: InlineResponse20011
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.g_et_account_account_id_favorite_tv_with_http_info(account_id, session_id, **kwargs)  # noqa: E501
        else:
            (data) = self.g_et_account_account_id_favorite_tv_with_http_info(account_id, session_id, **kwargs)  # noqa: E501
            return data

    def g_et_account_account_id_favorite_tv_with_http_info(self, account_id, session_id, **kwargs):  # noqa: E501
        """Get Favorite TV Shows  # noqa: E501

        Get the list of your favorite TV shows.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_account_account_id_favorite_tv_with_http_info(account_id, session_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int account_id: (required)
        :param str session_id: (required)
        :return: InlineResponse20011
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id', 'session_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method g_et_account_account_id_favorite_tv" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_id' is set
        if ('account_id' not in params or
                params['account_id'] is None):
            raise ValueError("Missing the required parameter `account_id` when calling `g_et_account_account_id_favorite_tv`")  # noqa: E501
        # verify the required parameter 'session_id' is set
        if ('session_id' not in params or
                params['session_id'] is None):
            raise ValueError("Missing the required parameter `session_id` when calling `g_et_account_account_id_favorite_tv`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'account_id' in params:
            path_params['account_id'] = params['account_id']  # noqa: E501

        query_params = []
        if 'session_id' in params:
            query_params.append(('session_id', params['session_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/account/{account_id}/favorite/tv', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20011',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def g_et_account_account_id_lists(self, account_id, session_id, **kwargs):  # noqa: E501
        """Get Created Lists  # noqa: E501

        Get all of the lists created by an account. Will invlude private lists if you are the owner.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_account_account_id_lists(account_id, session_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int account_id: (required)
        :param str session_id: (required)
        :param str api_key:
        :return: InlineResponse20054
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.g_et_account_account_id_lists_with_http_info(account_id, session_id, **kwargs)  # noqa: E501
        else:
            (data) = self.g_et_account_account_id_lists_with_http_info(account_id, session_id, **kwargs)  # noqa: E501
            return data

    def g_et_account_account_id_lists_with_http_info(self, account_id, session_id, **kwargs):  # noqa: E501
        """Get Created Lists  # noqa: E501

        Get all of the lists created by an account. Will invlude private lists if you are the owner.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_account_account_id_lists_with_http_info(account_id, session_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int account_id: (required)
        :param str session_id: (required)
        :param str api_key:
        :return: InlineResponse20054
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id', 'session_id', 'api_key']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method g_et_account_account_id_lists" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_id' is set
        if ('account_id' not in params or
                params['account_id'] is None):
            raise ValueError("Missing the required parameter `account_id` when calling `g_et_account_account_id_lists`")  # noqa: E501
        # verify the required parameter 'session_id' is set
        if ('session_id' not in params or
                params['session_id'] is None):
            raise ValueError("Missing the required parameter `session_id` when calling `g_et_account_account_id_lists`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'account_id' in params:
            path_params['account_id'] = params['account_id']  # noqa: E501

        query_params = []
        if 'api_key' in params:
            query_params.append(('api_key', params['api_key']))  # noqa: E501
        if 'session_id' in params:
            query_params.append(('session_id', params['session_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/account/{account_id}/lists', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20054',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def g_et_account_account_id_rated_movies(self, account_id, session_id, **kwargs):  # noqa: E501
        """Get Rated Movies  # noqa: E501

        Get a list of all the movies you have rated.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_account_account_id_rated_movies(account_id, session_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int account_id: (required)
        :param str session_id: (required)
        :return: InlineResponse20021
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.g_et_account_account_id_rated_movies_with_http_info(account_id, session_id, **kwargs)  # noqa: E501
        else:
            (data) = self.g_et_account_account_id_rated_movies_with_http_info(account_id, session_id, **kwargs)  # noqa: E501
            return data

    def g_et_account_account_id_rated_movies_with_http_info(self, account_id, session_id, **kwargs):  # noqa: E501
        """Get Rated Movies  # noqa: E501

        Get a list of all the movies you have rated.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_account_account_id_rated_movies_with_http_info(account_id, session_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int account_id: (required)
        :param str session_id: (required)
        :return: InlineResponse20021
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id', 'session_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method g_et_account_account_id_rated_movies" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_id' is set
        if ('account_id' not in params or
                params['account_id'] is None):
            raise ValueError("Missing the required parameter `account_id` when calling `g_et_account_account_id_rated_movies`")  # noqa: E501
        # verify the required parameter 'session_id' is set
        if ('session_id' not in params or
                params['session_id'] is None):
            raise ValueError("Missing the required parameter `session_id` when calling `g_et_account_account_id_rated_movies`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'account_id' in params:
            path_params['account_id'] = params['account_id']  # noqa: E501

        query_params = []
        if 'session_id' in params:
            query_params.append(('session_id', params['session_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/account/{account_id}/rated/movies', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20021',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def g_et_account_account_id_rated_tv(self, account_id, session_id, **kwargs):  # noqa: E501
        """Get Rated TV Shows  # noqa: E501

        Get a list of all the TV shows you have rated.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_account_account_id_rated_tv(account_id, session_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int account_id: (required)
        :param str session_id: (required)
        :return: InlineResponse2008
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.g_et_account_account_id_rated_tv_with_http_info(account_id, session_id, **kwargs)  # noqa: E501
        else:
            (data) = self.g_et_account_account_id_rated_tv_with_http_info(account_id, session_id, **kwargs)  # noqa: E501
            return data

    def g_et_account_account_id_rated_tv_with_http_info(self, account_id, session_id, **kwargs):  # noqa: E501
        """Get Rated TV Shows  # noqa: E501

        Get a list of all the TV shows you have rated.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_account_account_id_rated_tv_with_http_info(account_id, session_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int account_id: (required)
        :param str session_id: (required)
        :return: InlineResponse2008
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id', 'session_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method g_et_account_account_id_rated_tv" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_id' is set
        if ('account_id' not in params or
                params['account_id'] is None):
            raise ValueError("Missing the required parameter `account_id` when calling `g_et_account_account_id_rated_tv`")  # noqa: E501
        # verify the required parameter 'session_id' is set
        if ('session_id' not in params or
                params['session_id'] is None):
            raise ValueError("Missing the required parameter `session_id` when calling `g_et_account_account_id_rated_tv`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'account_id' in params:
            path_params['account_id'] = params['account_id']  # noqa: E501

        query_params = []
        if 'session_id' in params:
            query_params.append(('session_id', params['session_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/account/{account_id}/rated/tv', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2008',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def g_et_account_account_id_rated_tv_episodes(self, account_id, session_id, **kwargs):  # noqa: E501
        """Get Rated TV Episodes  # noqa: E501

        Get a list of all the TV episodes you have rated.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_account_account_id_rated_tv_episodes(account_id, session_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_id: (required)
        :param str session_id: (required)
        :return: InlineResponse2009
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.g_et_account_account_id_rated_tv_episodes_with_http_info(account_id, session_id, **kwargs)  # noqa: E501
        else:
            (data) = self.g_et_account_account_id_rated_tv_episodes_with_http_info(account_id, session_id, **kwargs)  # noqa: E501
            return data

    def g_et_account_account_id_rated_tv_episodes_with_http_info(self, account_id, session_id, **kwargs):  # noqa: E501
        """Get Rated TV Episodes  # noqa: E501

        Get a list of all the TV episodes you have rated.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_account_account_id_rated_tv_episodes_with_http_info(account_id, session_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str account_id: (required)
        :param str session_id: (required)
        :return: InlineResponse2009
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id', 'session_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method g_et_account_account_id_rated_tv_episodes" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_id' is set
        if ('account_id' not in params or
                params['account_id'] is None):
            raise ValueError("Missing the required parameter `account_id` when calling `g_et_account_account_id_rated_tv_episodes`")  # noqa: E501
        # verify the required parameter 'session_id' is set
        if ('session_id' not in params or
                params['session_id'] is None):
            raise ValueError("Missing the required parameter `session_id` when calling `g_et_account_account_id_rated_tv_episodes`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'account_id' in params:
            path_params['account_id'] = params['account_id']  # noqa: E501

        query_params = []
        if 'session_id' in params:
            query_params.append(('session_id', params['session_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/account/{account_id}/rated/tv/episodes', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2009',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def g_et_account_account_id_watchlist_movies(self, account_id, session_id, **kwargs):  # noqa: E501
        """Get Movie Watchlist  # noqa: E501

        Get a list of all the movies you have added to your watchlist.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_account_account_id_watchlist_movies(account_id, session_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int account_id: (required)
        :param str session_id: (required)
        :return: InlineResponse2001
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.g_et_account_account_id_watchlist_movies_with_http_info(account_id, session_id, **kwargs)  # noqa: E501
        else:
            (data) = self.g_et_account_account_id_watchlist_movies_with_http_info(account_id, session_id, **kwargs)  # noqa: E501
            return data

    def g_et_account_account_id_watchlist_movies_with_http_info(self, account_id, session_id, **kwargs):  # noqa: E501
        """Get Movie Watchlist  # noqa: E501

        Get a list of all the movies you have added to your watchlist.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_account_account_id_watchlist_movies_with_http_info(account_id, session_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int account_id: (required)
        :param str session_id: (required)
        :return: InlineResponse2001
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id', 'session_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method g_et_account_account_id_watchlist_movies" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_id' is set
        if ('account_id' not in params or
                params['account_id'] is None):
            raise ValueError("Missing the required parameter `account_id` when calling `g_et_account_account_id_watchlist_movies`")  # noqa: E501
        # verify the required parameter 'session_id' is set
        if ('session_id' not in params or
                params['session_id'] is None):
            raise ValueError("Missing the required parameter `session_id` when calling `g_et_account_account_id_watchlist_movies`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'account_id' in params:
            path_params['account_id'] = params['account_id']  # noqa: E501

        query_params = []
        if 'session_id' in params:
            query_params.append(('session_id', params['session_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/account/{account_id}/watchlist/movies', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2001',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def g_et_account_account_id_watchlist_tv(self, account_id, session_id, **kwargs):  # noqa: E501
        """Get TV Show Watchlist  # noqa: E501

        Get a list of all the TV shows you have added to your watchlist.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_account_account_id_watchlist_tv(account_id, session_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int account_id: (required)
        :param str session_id: (required)
        :return: InlineResponse20011
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.g_et_account_account_id_watchlist_tv_with_http_info(account_id, session_id, **kwargs)  # noqa: E501
        else:
            (data) = self.g_et_account_account_id_watchlist_tv_with_http_info(account_id, session_id, **kwargs)  # noqa: E501
            return data

    def g_et_account_account_id_watchlist_tv_with_http_info(self, account_id, session_id, **kwargs):  # noqa: E501
        """Get TV Show Watchlist  # noqa: E501

        Get a list of all the TV shows you have added to your watchlist.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_account_account_id_watchlist_tv_with_http_info(account_id, session_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int account_id: (required)
        :param str session_id: (required)
        :return: InlineResponse20011
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id', 'session_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method g_et_account_account_id_watchlist_tv" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_id' is set
        if ('account_id' not in params or
                params['account_id'] is None):
            raise ValueError("Missing the required parameter `account_id` when calling `g_et_account_account_id_watchlist_tv`")  # noqa: E501
        # verify the required parameter 'session_id' is set
        if ('session_id' not in params or
                params['session_id'] is None):
            raise ValueError("Missing the required parameter `session_id` when calling `g_et_account_account_id_watchlist_tv`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'account_id' in params:
            path_params['account_id'] = params['account_id']  # noqa: E501

        query_params = []
        if 'session_id' in params:
            query_params.append(('session_id', params['session_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/account/{account_id}/watchlist/tv', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20011',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def g_et_authentication_guest_session_new(self, **kwargs):  # noqa: E501
        """Create Guest Session  # noqa: E501

        This method will let you create a new guest session. Guest sessions are a type of session that will let a user rate movies and TV shows but not require them to have a TMDb user account. More information about user authentication can be found [here](#docTextSection:NSZtgz7zptsiLYxXZ).  Please note, you should only generate a single guest session per user (or device) as you will be able to attach the ratings to a TMDb user account in the future. There is also IP limits in place so you should always make sure it's the end user doing the guest session actions.  If a guest session is not used for the first time within 24 hours, it will be automatically deleted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_authentication_guest_session_new(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse20057
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.g_et_authentication_guest_session_new_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.g_et_authentication_guest_session_new_with_http_info(**kwargs)  # noqa: E501
            return data

    def g_et_authentication_guest_session_new_with_http_info(self, **kwargs):  # noqa: E501
        """Create Guest Session  # noqa: E501

        This method will let you create a new guest session. Guest sessions are a type of session that will let a user rate movies and TV shows but not require them to have a TMDb user account. More information about user authentication can be found [here](#docTextSection:NSZtgz7zptsiLYxXZ).  Please note, you should only generate a single guest session per user (or device) as you will be able to attach the ratings to a TMDb user account in the future. There is also IP limits in place so you should always make sure it's the end user doing the guest session actions.  If a guest session is not used for the first time within 24 hours, it will be automatically deleted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_authentication_guest_session_new_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse20057
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method g_et_authentication_guest_session_new" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/authentication/guest_session/new', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20057',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def g_et_authentication_token_new(self, **kwargs):  # noqa: E501
        """Create Request Token  # noqa: E501

        Create a temporary request token that can be used to validate a TMDb user login. More details about how this works can be found [here](#docTextSection:NSZtgz7zptsiLYxXZ).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_authentication_token_new(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse20030
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.g_et_authentication_token_new_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.g_et_authentication_token_new_with_http_info(**kwargs)  # noqa: E501
            return data

    def g_et_authentication_token_new_with_http_info(self, **kwargs):  # noqa: E501
        """Create Request Token  # noqa: E501

        Create a temporary request token that can be used to validate a TMDb user login. More details about how this works can be found [here](#docTextSection:NSZtgz7zptsiLYxXZ).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_authentication_token_new_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse20030
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method g_et_authentication_token_new" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/authentication/token/new', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20030',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def g_et_certification_movie_list(self, **kwargs):  # noqa: E501
        """Get Movie Certifications  # noqa: E501

        Get an up to date list of the officially supported movie certifications on TMDb.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_certification_movie_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse20071
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.g_et_certification_movie_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.g_et_certification_movie_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def g_et_certification_movie_list_with_http_info(self, **kwargs):  # noqa: E501
        """Get Movie Certifications  # noqa: E501

        Get an up to date list of the officially supported movie certifications on TMDb.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_certification_movie_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse20071
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method g_et_certification_movie_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/certification/movie/list', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20071',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def g_et_certification_tv_list(self, **kwargs):  # noqa: E501
        """Get TV Certifications  # noqa: E501

        Get an up to date list of the officially supported TV show certifications on TMDb.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_certification_tv_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse20080
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.g_et_certification_tv_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.g_et_certification_tv_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def g_et_certification_tv_list_with_http_info(self, **kwargs):  # noqa: E501
        """Get TV Certifications  # noqa: E501

        Get an up to date list of the officially supported TV show certifications on TMDb.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_certification_tv_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse20080
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method g_et_certification_tv_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/certification/tv/list', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20080',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def g_et_collection_collection_id(self, collection_id, **kwargs):  # noqa: E501
        """Get Details  # noqa: E501

        Get collection details by id.  #### Recent Changes  | **Date** | **Change** | | - | - | | March 16, 2018 | Added the [translations](#endpoint:bhcsxEgRvyk3N7FnD) method. |  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_collection_collection_id(collection_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int collection_id: (required)
        :return: InlineResponse20079
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.g_et_collection_collection_id_with_http_info(collection_id, **kwargs)  # noqa: E501
        else:
            (data) = self.g_et_collection_collection_id_with_http_info(collection_id, **kwargs)  # noqa: E501
            return data

    def g_et_collection_collection_id_with_http_info(self, collection_id, **kwargs):  # noqa: E501
        """Get Details  # noqa: E501

        Get collection details by id.  #### Recent Changes  | **Date** | **Change** | | - | - | | March 16, 2018 | Added the [translations](#endpoint:bhcsxEgRvyk3N7FnD) method. |  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_collection_collection_id_with_http_info(collection_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int collection_id: (required)
        :return: InlineResponse20079
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['collection_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method g_et_collection_collection_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'collection_id' is set
        if ('collection_id' not in params or
                params['collection_id'] is None):
            raise ValueError("Missing the required parameter `collection_id` when calling `g_et_collection_collection_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'collection_id' in params:
            path_params['collection_id'] = params['collection_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/collection/{collection_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20079',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def g_et_collection_collection_id_images(self, collection_id, **kwargs):  # noqa: E501
        """Get Images  # noqa: E501

        Get the images for a collection by id.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_collection_collection_id_images(collection_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int collection_id: (required)
        :return: InlineResponse20088
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.g_et_collection_collection_id_images_with_http_info(collection_id, **kwargs)  # noqa: E501
        else:
            (data) = self.g_et_collection_collection_id_images_with_http_info(collection_id, **kwargs)  # noqa: E501
            return data

    def g_et_collection_collection_id_images_with_http_info(self, collection_id, **kwargs):  # noqa: E501
        """Get Images  # noqa: E501

        Get the images for a collection by id.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_collection_collection_id_images_with_http_info(collection_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int collection_id: (required)
        :return: InlineResponse20088
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['collection_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method g_et_collection_collection_id_images" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'collection_id' is set
        if ('collection_id' not in params or
                params['collection_id'] is None):
            raise ValueError("Missing the required parameter `collection_id` when calling `g_et_collection_collection_id_images`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'collection_id' in params:
            path_params['collection_id'] = params['collection_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/collection/{collection_id}/images', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20088',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def g_et_collection_collection_id_translations(self, collection_id, **kwargs):  # noqa: E501
        """Get Translations  # noqa: E501

        Get the list translations for a collection by id.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_collection_collection_id_translations(collection_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int collection_id: (required)
        :return: InlineResponse20043
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.g_et_collection_collection_id_translations_with_http_info(collection_id, **kwargs)  # noqa: E501
        else:
            (data) = self.g_et_collection_collection_id_translations_with_http_info(collection_id, **kwargs)  # noqa: E501
            return data

    def g_et_collection_collection_id_translations_with_http_info(self, collection_id, **kwargs):  # noqa: E501
        """Get Translations  # noqa: E501

        Get the list translations for a collection by id.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_collection_collection_id_translations_with_http_info(collection_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int collection_id: (required)
        :return: InlineResponse20043
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['collection_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method g_et_collection_collection_id_translations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'collection_id' is set
        if ('collection_id' not in params or
                params['collection_id'] is None):
            raise ValueError("Missing the required parameter `collection_id` when calling `g_et_collection_collection_id_translations`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'collection_id' in params:
            path_params['collection_id'] = params['collection_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/collection/{collection_id}/translations', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20043',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def g_et_company_company_id(self, company_id, **kwargs):  # noqa: E501
        """Get Details  # noqa: E501

        Get a companies details by id.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_company_company_id(company_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int company_id: (required)
        :return: InlineResponse20036
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.g_et_company_company_id_with_http_info(company_id, **kwargs)  # noqa: E501
        else:
            (data) = self.g_et_company_company_id_with_http_info(company_id, **kwargs)  # noqa: E501
            return data

    def g_et_company_company_id_with_http_info(self, company_id, **kwargs):  # noqa: E501
        """Get Details  # noqa: E501

        Get a companies details by id.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_company_company_id_with_http_info(company_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int company_id: (required)
        :return: InlineResponse20036
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['company_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method g_et_company_company_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'company_id' is set
        if ('company_id' not in params or
                params['company_id'] is None):
            raise ValueError("Missing the required parameter `company_id` when calling `g_et_company_company_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'company_id' in params:
            path_params['company_id'] = params['company_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/company/{company_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20036',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def g_et_company_company_id_alternative_names(self, company_id, **kwargs):  # noqa: E501
        """Get Alternative Names  # noqa: E501

        Get the alternative names of a company.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_company_company_id_alternative_names(company_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int company_id: (required)
        :return: InlineResponse20040
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.g_et_company_company_id_alternative_names_with_http_info(company_id, **kwargs)  # noqa: E501
        else:
            (data) = self.g_et_company_company_id_alternative_names_with_http_info(company_id, **kwargs)  # noqa: E501
            return data

    def g_et_company_company_id_alternative_names_with_http_info(self, company_id, **kwargs):  # noqa: E501
        """Get Alternative Names  # noqa: E501

        Get the alternative names of a company.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_company_company_id_alternative_names_with_http_info(company_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int company_id: (required)
        :return: InlineResponse20040
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['company_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method g_et_company_company_id_alternative_names" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'company_id' is set
        if ('company_id' not in params or
                params['company_id'] is None):
            raise ValueError("Missing the required parameter `company_id` when calling `g_et_company_company_id_alternative_names`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'company_id' in params:
            path_params['company_id'] = params['company_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/company/{company_id}/alternative_names', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20040',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def g_et_company_company_id_images(self, company_id, **kwargs):  # noqa: E501
        """Get Images  # noqa: E501

        Get a companies logos by id.  There are two image formats that are supported for companies, PNG's and SVG's. You can see which type the original file is by looking at the `file_type` field. We prefer SVG's as they are resolution independent and as such, the width and height are only there to reflect the original asset that was uploaded. An SVG can be scaled properly beyond those dimensions if you call them as a PNG.  For more information about how SVG's and PNG's can be used, take a read through [this document](#docTextSection:mXP9B2uzoDJFguDZv).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_company_company_id_images(company_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int company_id: (required)
        :return: InlineResponse20023
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.g_et_company_company_id_images_with_http_info(company_id, **kwargs)  # noqa: E501
        else:
            (data) = self.g_et_company_company_id_images_with_http_info(company_id, **kwargs)  # noqa: E501
            return data

    def g_et_company_company_id_images_with_http_info(self, company_id, **kwargs):  # noqa: E501
        """Get Images  # noqa: E501

        Get a companies logos by id.  There are two image formats that are supported for companies, PNG's and SVG's. You can see which type the original file is by looking at the `file_type` field. We prefer SVG's as they are resolution independent and as such, the width and height are only there to reflect the original asset that was uploaded. An SVG can be scaled properly beyond those dimensions if you call them as a PNG.  For more information about how SVG's and PNG's can be used, take a read through [this document](#docTextSection:mXP9B2uzoDJFguDZv).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_company_company_id_images_with_http_info(company_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int company_id: (required)
        :return: InlineResponse20023
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['company_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method g_et_company_company_id_images" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'company_id' is set
        if ('company_id' not in params or
                params['company_id'] is None):
            raise ValueError("Missing the required parameter `company_id` when calling `g_et_company_company_id_images`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'company_id' in params:
            path_params['company_id'] = params['company_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/company/{company_id}/images', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20023',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def g_et_configuration(self, **kwargs):  # noqa: E501
        """Get API Configuration  # noqa: E501

        Get the system wide configuration information. Some elements of the API require some knowledge of this configuration data. The purpose of this is to try and keep the actual API responses as light as possible. It is recommended you cache this data within your application and check for updates every few days.  This method currently holds the data relevant to building image URLs as well as the change key map.  To build an image URL, you will need 3 pieces of data. The `base_url`, `size` and `file_path`. Simply combine them all and you will have a fully qualified URL. Heres an example URL:      https://image.tmdb.org/t/p/w500/8uO0gUM8aNqYLs1OsTBQiXu0fEv.jpg  The configuration method also contains the list of change keys which can be useful if you are building an app that consumes data from the change feed.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_configuration(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str api_key:
        :return: InlineResponse20092
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.g_et_configuration_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.g_et_configuration_with_http_info(**kwargs)  # noqa: E501
            return data

    def g_et_configuration_with_http_info(self, **kwargs):  # noqa: E501
        """Get API Configuration  # noqa: E501

        Get the system wide configuration information. Some elements of the API require some knowledge of this configuration data. The purpose of this is to try and keep the actual API responses as light as possible. It is recommended you cache this data within your application and check for updates every few days.  This method currently holds the data relevant to building image URLs as well as the change key map.  To build an image URL, you will need 3 pieces of data. The `base_url`, `size` and `file_path`. Simply combine them all and you will have a fully qualified URL. Heres an example URL:      https://image.tmdb.org/t/p/w500/8uO0gUM8aNqYLs1OsTBQiXu0fEv.jpg  The configuration method also contains the list of change keys which can be useful if you are building an app that consumes data from the change feed.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_configuration_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str api_key:
        :return: InlineResponse20092
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['api_key']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method g_et_configuration" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'api_key' in params:
            query_params.append(('api_key', params['api_key']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/configuration', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20092',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def g_et_configuration_countries(self, **kwargs):  # noqa: E501
        """Get Countries  # noqa: E501

        Get the list of countries (ISO 3166-1 tags) used throughout TMDb.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_configuration_countries(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str api_key:
        :return: list[InlineResponse20060]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.g_et_configuration_countries_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.g_et_configuration_countries_with_http_info(**kwargs)  # noqa: E501
            return data

    def g_et_configuration_countries_with_http_info(self, **kwargs):  # noqa: E501
        """Get Countries  # noqa: E501

        Get the list of countries (ISO 3166-1 tags) used throughout TMDb.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_configuration_countries_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str api_key:
        :return: list[InlineResponse20060]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['api_key']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method g_et_configuration_countries" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'api_key' in params:
            query_params.append(('api_key', params['api_key']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/configuration/countries', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[InlineResponse20060]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def g_et_configuration_jobs(self, **kwargs):  # noqa: E501
        """Get Jobs  # noqa: E501

        Get a list of the jobs and departments we use on TMDb.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_configuration_jobs(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str api_key:
        :return: list[InlineResponse20013]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.g_et_configuration_jobs_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.g_et_configuration_jobs_with_http_info(**kwargs)  # noqa: E501
            return data

    def g_et_configuration_jobs_with_http_info(self, **kwargs):  # noqa: E501
        """Get Jobs  # noqa: E501

        Get a list of the jobs and departments we use on TMDb.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_configuration_jobs_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str api_key:
        :return: list[InlineResponse20013]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['api_key']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method g_et_configuration_jobs" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'api_key' in params:
            query_params.append(('api_key', params['api_key']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/configuration/jobs', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[InlineResponse20013]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def g_et_configuration_languages(self, **kwargs):  # noqa: E501
        """Get Languages  # noqa: E501

        Get the list of languages (ISO 639-1 tags) used throughout TMDb.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_configuration_languages(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str api_key:
        :return: list[InlineResponse2007]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.g_et_configuration_languages_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.g_et_configuration_languages_with_http_info(**kwargs)  # noqa: E501
            return data

    def g_et_configuration_languages_with_http_info(self, **kwargs):  # noqa: E501
        """Get Languages  # noqa: E501

        Get the list of languages (ISO 639-1 tags) used throughout TMDb.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_configuration_languages_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str api_key:
        :return: list[InlineResponse2007]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['api_key']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method g_et_configuration_languages" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'api_key' in params:
            query_params.append(('api_key', params['api_key']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/configuration/languages', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[InlineResponse2007]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def g_et_configuration_primary_translations(self, **kwargs):  # noqa: E501
        """Get Primary Translations  # noqa: E501

        Get a list of the _officially_ supported translations on TMDb.  While it's technically possible to add a translation in any one of the [languages](#endpoint:tem8QfFFyAfWodrCv) we have added to TMDb (we don't restrict content), the ones listed in this method are the ones we also support for localizing the website with which means they are what we refer to as the \"primary\" translations.  These are all specified as [IETF tags](https://en.wikipedia.org/wiki/IETF_language_tag) to identify the languages we use on TMDb. There is one exception which is image languages. They are currently only designated by a ISO-639-1 tag. This is a planned upgrade for the future.  We're always open to adding more if you think one should be added. You can ask about getting a new primary translation added by posting on [the forums](https://www.themoviedb.org/talk/category/5047951f760ee3318900009a).  One more thing to mention, these are the translations that map to our website translation project. You can view and contribute to that project [here](https://www.localeapp.com/projects/8267).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_configuration_primary_translations(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str api_key:
        :return: list[str]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.g_et_configuration_primary_translations_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.g_et_configuration_primary_translations_with_http_info(**kwargs)  # noqa: E501
            return data

    def g_et_configuration_primary_translations_with_http_info(self, **kwargs):  # noqa: E501
        """Get Primary Translations  # noqa: E501

        Get a list of the _officially_ supported translations on TMDb.  While it's technically possible to add a translation in any one of the [languages](#endpoint:tem8QfFFyAfWodrCv) we have added to TMDb (we don't restrict content), the ones listed in this method are the ones we also support for localizing the website with which means they are what we refer to as the \"primary\" translations.  These are all specified as [IETF tags](https://en.wikipedia.org/wiki/IETF_language_tag) to identify the languages we use on TMDb. There is one exception which is image languages. They are currently only designated by a ISO-639-1 tag. This is a planned upgrade for the future.  We're always open to adding more if you think one should be added. You can ask about getting a new primary translation added by posting on [the forums](https://www.themoviedb.org/talk/category/5047951f760ee3318900009a).  One more thing to mention, these are the translations that map to our website translation project. You can view and contribute to that project [here](https://www.localeapp.com/projects/8267).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_configuration_primary_translations_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str api_key:
        :return: list[str]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['api_key']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method g_et_configuration_primary_translations" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'api_key' in params:
            query_params.append(('api_key', params['api_key']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/configuration/primary_translations', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[str]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def g_et_configuration_timezones(self, **kwargs):  # noqa: E501
        """Get Timezones  # noqa: E501

        Get the list of timezones used throughout TMDb.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_configuration_timezones(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str api_key:
        :return: list[InlineResponse20014]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.g_et_configuration_timezones_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.g_et_configuration_timezones_with_http_info(**kwargs)  # noqa: E501
            return data

    def g_et_configuration_timezones_with_http_info(self, **kwargs):  # noqa: E501
        """Get Timezones  # noqa: E501

        Get the list of timezones used throughout TMDb.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_configuration_timezones_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str api_key:
        :return: list[InlineResponse20014]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['api_key']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method g_et_configuration_timezones" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'api_key' in params:
            query_params.append(('api_key', params['api_key']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/configuration/timezones', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[InlineResponse20014]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def g_et_credit_credit_id(self, credit_id, **kwargs):  # noqa: E501
        """Get Details  # noqa: E501

        Get a movie or TV credit details by id.  #### Recent Changes  | **Date** | **Change** | | - | - | | July 13, 2018 | Movie credits are now supported. |  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_credit_credit_id(credit_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str credit_id: (required)
        :return: InlineResponse20051
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.g_et_credit_credit_id_with_http_info(credit_id, **kwargs)  # noqa: E501
        else:
            (data) = self.g_et_credit_credit_id_with_http_info(credit_id, **kwargs)  # noqa: E501
            return data

    def g_et_credit_credit_id_with_http_info(self, credit_id, **kwargs):  # noqa: E501
        """Get Details  # noqa: E501

        Get a movie or TV credit details by id.  #### Recent Changes  | **Date** | **Change** | | - | - | | July 13, 2018 | Movie credits are now supported. |  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_credit_credit_id_with_http_info(credit_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str credit_id: (required)
        :return: InlineResponse20051
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['credit_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method g_et_credit_credit_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'credit_id' is set
        if ('credit_id' not in params or
                params['credit_id'] is None):
            raise ValueError("Missing the required parameter `credit_id` when calling `g_et_credit_credit_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'credit_id' in params:
            path_params['credit_id'] = params['credit_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/credit/{credit_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20051',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def g_et_discover_movie(self, **kwargs):  # noqa: E501
        """Movie Discover  # noqa: E501

        Discover movies by different types of data like average rating, number of votes, genres and certifications. You can get a valid list of certifications from the [certifications list](#endpoint:faFKjuKG2HnwexAWM) method.  Discover also supports a nice list of sort options. See below for all of the available options.  Please note, when using `certification` \\ `certification.lte` you must also specify `certification_country`. These two parameters work together in order to filter the results. You can only filter results with the countries we have added to our [certifications list](#endpoint:faFKjuKG2HnwexAWM).  If you specify the `region` parameter, the regional release date will be used instead of the primary release date. The date returned will be the first date based on your query (ie. if a `with_release_type` is specified). It's important to note the order of the release types that are used. Specifying \"2|3\" would return the limited theatrical release date as opposed to \"3|2\" which would return the theatrical date.  Also note that a number of filters support being comma (`,`) or pipe (`|`) separated. Comma's are treated like an `AND` and query while pipe's are an `OR`.   Some examples of what can be done with discover can be found [here](https://www.themoviedb.org/documentation/api/discover).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_discover_movie(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str sort_by: Choose from one of the many available sort options.
        :param str certification_country: Used in conjunction with the certification filter, use this to specify a country with a valid certification.
        :param str certification: Filter results with a valid certification from the 'certification_country' field.
        :param str certification_lte: Filter and only include movies that have a certification that is less than or equal to the specified value.
        :param str certification_gte: Filter and only include movies that have a certification that is greater than or equal to the specified value.
        :param bool include_adult: A filter and include or exclude adult movies.
        :param bool include_video: A filter to include or exclude videos.
        :param str language: Specify a language to query translatable fields with.
        :param int page: Specify the page of results to query.
        :param int primary_release_year: A filter to limit the results to a specific primary release year.
        :param date primary_release_date_gte: Filter and only include movies that have a primary release date that is greater or equal to the specified value.
        :param date primary_release_date_lte: Filter and only include movies that have a primary release date that is less than or equal to the specified value.
        :param date release_date_gte: Filter and only include movies that have a release date (looking at all release dates) that is greater or equal to the specified value.
        :param date release_date_lte: Filter and only include movies that have a release date (looking at all release dates) that is less than or equal to the specified value.
        :param int with_release_type: Specify a comma (AND) or pipe (OR) separated value to filter release types by. These release types map to the same values found on the movie release date method.
        :param int year: A filter to limit the results to a specific year (looking at all release dates).
        :param int vote_count_gte: Filter and only include movies that have a vote count that is greater or equal to the specified value.
        :param int vote_count_lte: Filter and only include movies that have a vote count that is less than or equal to the specified value.
        :param float vote_average_gte: Filter and only include movies that have a rating that is greater or equal to the specified value.
        :param float vote_average_lte: Filter and only include movies that have a rating that is less than or equal to the specified value.
        :param str with_cast: A comma separated list of person ID's. Only include movies that have one of the ID's added as an actor.
        :param str with_crew: A comma separated list of person ID's. Only include movies that have one of the ID's added as a crew member.
        :param str with_people: A comma separated list of person ID's. Only include movies that have one of the ID's added as a either a actor or a crew member.
        :param str with_companies: A comma separated list of production company ID's. Only include movies that have one of the ID's added as a production company.
        :param str with_genres: Comma separated value of genre ids that you want to include in the results.
        :param str without_genres: Comma separated value of genre ids that you want to exclude from the results.
        :param str with_keywords: A comma separated list of keyword ID's. Only includes movies that have one of the ID's added as a keyword.
        :param str without_keywords: Exclude items with certain keywords. You can comma and pipe seperate these values to create an 'AND' or 'OR' logic.
        :param int with_runtime_gte: Filter and only include movies that have a runtime that is greater or equal to a value.
        :param int with_runtime_lte: Filter and only include movies that have a runtime that is less than or equal to a value.
        :param str with_original_language: Specify an ISO 639-1 string to filter results by their original language value.
        :return: InlineResponse20027
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.g_et_discover_movie_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.g_et_discover_movie_with_http_info(**kwargs)  # noqa: E501
            return data

    def g_et_discover_movie_with_http_info(self, **kwargs):  # noqa: E501
        """Movie Discover  # noqa: E501

        Discover movies by different types of data like average rating, number of votes, genres and certifications. You can get a valid list of certifications from the [certifications list](#endpoint:faFKjuKG2HnwexAWM) method.  Discover also supports a nice list of sort options. See below for all of the available options.  Please note, when using `certification` \\ `certification.lte` you must also specify `certification_country`. These two parameters work together in order to filter the results. You can only filter results with the countries we have added to our [certifications list](#endpoint:faFKjuKG2HnwexAWM).  If you specify the `region` parameter, the regional release date will be used instead of the primary release date. The date returned will be the first date based on your query (ie. if a `with_release_type` is specified). It's important to note the order of the release types that are used. Specifying \"2|3\" would return the limited theatrical release date as opposed to \"3|2\" which would return the theatrical date.  Also note that a number of filters support being comma (`,`) or pipe (`|`) separated. Comma's are treated like an `AND` and query while pipe's are an `OR`.   Some examples of what can be done with discover can be found [here](https://www.themoviedb.org/documentation/api/discover).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_discover_movie_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str sort_by: Choose from one of the many available sort options.
        :param str certification_country: Used in conjunction with the certification filter, use this to specify a country with a valid certification.
        :param str certification: Filter results with a valid certification from the 'certification_country' field.
        :param str certification_lte: Filter and only include movies that have a certification that is less than or equal to the specified value.
        :param str certification_gte: Filter and only include movies that have a certification that is greater than or equal to the specified value.
        :param bool include_adult: A filter and include or exclude adult movies.
        :param bool include_video: A filter to include or exclude videos.
        :param str language: Specify a language to query translatable fields with.
        :param int page: Specify the page of results to query.
        :param int primary_release_year: A filter to limit the results to a specific primary release year.
        :param date primary_release_date_gte: Filter and only include movies that have a primary release date that is greater or equal to the specified value.
        :param date primary_release_date_lte: Filter and only include movies that have a primary release date that is less than or equal to the specified value.
        :param date release_date_gte: Filter and only include movies that have a release date (looking at all release dates) that is greater or equal to the specified value.
        :param date release_date_lte: Filter and only include movies that have a release date (looking at all release dates) that is less than or equal to the specified value.
        :param int with_release_type: Specify a comma (AND) or pipe (OR) separated value to filter release types by. These release types map to the same values found on the movie release date method.
        :param int year: A filter to limit the results to a specific year (looking at all release dates).
        :param int vote_count_gte: Filter and only include movies that have a vote count that is greater or equal to the specified value.
        :param int vote_count_lte: Filter and only include movies that have a vote count that is less than or equal to the specified value.
        :param float vote_average_gte: Filter and only include movies that have a rating that is greater or equal to the specified value.
        :param float vote_average_lte: Filter and only include movies that have a rating that is less than or equal to the specified value.
        :param str with_cast: A comma separated list of person ID's. Only include movies that have one of the ID's added as an actor.
        :param str with_crew: A comma separated list of person ID's. Only include movies that have one of the ID's added as a crew member.
        :param str with_people: A comma separated list of person ID's. Only include movies that have one of the ID's added as a either a actor or a crew member.
        :param str with_companies: A comma separated list of production company ID's. Only include movies that have one of the ID's added as a production company.
        :param str with_genres: Comma separated value of genre ids that you want to include in the results.
        :param str without_genres: Comma separated value of genre ids that you want to exclude from the results.
        :param str with_keywords: A comma separated list of keyword ID's. Only includes movies that have one of the ID's added as a keyword.
        :param str without_keywords: Exclude items with certain keywords. You can comma and pipe seperate these values to create an 'AND' or 'OR' logic.
        :param int with_runtime_gte: Filter and only include movies that have a runtime that is greater or equal to a value.
        :param int with_runtime_lte: Filter and only include movies that have a runtime that is less than or equal to a value.
        :param str with_original_language: Specify an ISO 639-1 string to filter results by their original language value.
        :return: InlineResponse20027
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['sort_by', 'certification_country', 'certification', 'certification_lte', 'certification_gte', 'include_adult', 'include_video', 'language', 'page', 'primary_release_year', 'primary_release_date_gte', 'primary_release_date_lte', 'release_date_gte', 'release_date_lte', 'with_release_type', 'year', 'vote_count_gte', 'vote_count_lte', 'vote_average_gte', 'vote_average_lte', 'with_cast', 'with_crew', 'with_people', 'with_companies', 'with_genres', 'without_genres', 'with_keywords', 'without_keywords', 'with_runtime_gte', 'with_runtime_lte', 'with_original_language']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method g_et_discover_movie" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501
        if 'certification_country' in params:
            query_params.append(('certification_country', params['certification_country']))  # noqa: E501
        if 'certification' in params:
            query_params.append(('certification', params['certification']))  # noqa: E501
        if 'certification_lte' in params:
            query_params.append(('certification.lte', params['certification_lte']))  # noqa: E501
        if 'certification_gte' in params:
            query_params.append(('certification.gte', params['certification_gte']))  # noqa: E501
        if 'include_adult' in params:
            query_params.append(('include_adult', params['include_adult']))  # noqa: E501
        if 'include_video' in params:
            query_params.append(('include_video', params['include_video']))  # noqa: E501
        if 'language' in params:
            query_params.append(('language', params['language']))  # noqa: E501
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'primary_release_year' in params:
            query_params.append(('primary_release_year', params['primary_release_year']))  # noqa: E501
        if 'primary_release_date_gte' in params:
            query_params.append(('primary_release_date.gte', params['primary_release_date_gte']))  # noqa: E501
        if 'primary_release_date_lte' in params:
            query_params.append(('primary_release_date.lte', params['primary_release_date_lte']))  # noqa: E501
        if 'release_date_gte' in params:
            query_params.append(('release_date.gte', params['release_date_gte']))  # noqa: E501
        if 'release_date_lte' in params:
            query_params.append(('release_date.lte', params['release_date_lte']))  # noqa: E501
        if 'with_release_type' in params:
            query_params.append(('with_release_type', params['with_release_type']))  # noqa: E501
        if 'year' in params:
            query_params.append(('year', params['year']))  # noqa: E501
        if 'vote_count_gte' in params:
            query_params.append(('vote_count.gte', params['vote_count_gte']))  # noqa: E501
        if 'vote_count_lte' in params:
            query_params.append(('vote_count.lte', params['vote_count_lte']))  # noqa: E501
        if 'vote_average_gte' in params:
            query_params.append(('vote_average.gte', params['vote_average_gte']))  # noqa: E501
        if 'vote_average_lte' in params:
            query_params.append(('vote_average.lte', params['vote_average_lte']))  # noqa: E501
        if 'with_cast' in params:
            query_params.append(('with_cast', params['with_cast']))  # noqa: E501
        if 'with_crew' in params:
            query_params.append(('with_crew', params['with_crew']))  # noqa: E501
        if 'with_people' in params:
            query_params.append(('with_people', params['with_people']))  # noqa: E501
        if 'with_companies' in params:
            query_params.append(('with_companies', params['with_companies']))  # noqa: E501
        if 'with_genres' in params:
            query_params.append(('with_genres', params['with_genres']))  # noqa: E501
        if 'without_genres' in params:
            query_params.append(('without_genres', params['without_genres']))  # noqa: E501
        if 'with_keywords' in params:
            query_params.append(('with_keywords', params['with_keywords']))  # noqa: E501
        if 'without_keywords' in params:
            query_params.append(('without_keywords', params['without_keywords']))  # noqa: E501
        if 'with_runtime_gte' in params:
            query_params.append(('with_runtime.gte', params['with_runtime_gte']))  # noqa: E501
        if 'with_runtime_lte' in params:
            query_params.append(('with_runtime.lte', params['with_runtime_lte']))  # noqa: E501
        if 'with_original_language' in params:
            query_params.append(('with_original_language', params['with_original_language']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/discover/movie', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20027',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def g_et_discover_tv(self, **kwargs):  # noqa: E501
        """TV Discover  # noqa: E501

        Discover TV shows by different types of data like average rating, number of votes, genres, the network they aired on and air dates.  Discover also supports a nice list of sort options. See below for all of the available options.  Also note that a number of filters support being comma (`,`) or pipe (`|`) separated. Comma's are treated like an `AND` and query while pipe's are an `OR`.   Some examples of what can be done with discover can be found [here](https://www.themoviedb.org/documentation/api/discover).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_discover_tv(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str sort_by: Choose from one of the many available sort options.
        :param date air_date_gte: Filter and only include TV shows that have a air date (by looking at all episodes) that is greater or equal to the specified value.
        :param date air_date_lte: Filter and only include TV shows that have a air date (by looking at all episodes) that is less than or equal to the specified value.
        :param date first_air_date_gte: Filter and only include TV shows that have a original air date that is greater or equal to the specified value. Can be used in conjunction with the \"include_null_first_air_dates\" filter if you want to include items with no air date.
        :param date first_air_date_lte: Filter and only include TV shows that have a original air date that is less than or equal to the specified value. Can be used in conjunction with the \"include_null_first_air_dates\" filter if you want to include items with no air date.
        :param int first_air_date_year: Filter and only include TV shows that have a original air date year that equal to the specified value. Can be used in conjunction with the \"include_null_first_air_dates\" filter if you want to include items with no air date.
        :param str language: Specify a language to query translatable fields with.
        :param int page: Specify the page of results to query.
        :param str timezone: Used in conjunction with the air_date.gte/lte filter to calculate the proper UTC offset.
        :param float vote_average_gte: Filter and only include movies that have a rating that is greater or equal to the specified value.
        :param int vote_count_gte: Filter and only include movies that have a rating that is less than or equal to the specified value.
        :param str with_genres: Comma separated value of genre ids that you want to include in the results.
        :param str with_networks: Comma separated value of network ids that you want to include in the results.
        :param str without_genres: Comma separated value of genre ids that you want to exclude from the results.
        :param int with_runtime_gte: Filter and only include TV shows with an episode runtime that is greater than or equal to a value.
        :param int with_runtime_lte: Filter and only include TV shows with an episode runtime that is less than or equal to a value.
        :param bool include_null_first_air_dates: Use this filter to include TV shows that don't have an air date while using any of the \"first_air_date\" filters.
        :param str with_original_language: Specify an ISO 639-1 string to filter results by their original language value.
        :param str without_keywords: Exclude items with certain keywords. You can comma and pipe seperate these values to create an 'AND' or 'OR' logic.
        :param bool screened_theatrically: Filter results to include items that have been screened theatrically.
        :param str with_companies: A comma separated list of production company ID's. Only include movies that have one of the ID's added as a production company.
        :param str with_keywords: A comma separated list of keyword ID's. Only includes TV shows that have one of the ID's added as a keyword.
        :return: InlineResponse20024
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.g_et_discover_tv_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.g_et_discover_tv_with_http_info(**kwargs)  # noqa: E501
            return data

    def g_et_discover_tv_with_http_info(self, **kwargs):  # noqa: E501
        """TV Discover  # noqa: E501

        Discover TV shows by different types of data like average rating, number of votes, genres, the network they aired on and air dates.  Discover also supports a nice list of sort options. See below for all of the available options.  Also note that a number of filters support being comma (`,`) or pipe (`|`) separated. Comma's are treated like an `AND` and query while pipe's are an `OR`.   Some examples of what can be done with discover can be found [here](https://www.themoviedb.org/documentation/api/discover).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_discover_tv_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str sort_by: Choose from one of the many available sort options.
        :param date air_date_gte: Filter and only include TV shows that have a air date (by looking at all episodes) that is greater or equal to the specified value.
        :param date air_date_lte: Filter and only include TV shows that have a air date (by looking at all episodes) that is less than or equal to the specified value.
        :param date first_air_date_gte: Filter and only include TV shows that have a original air date that is greater or equal to the specified value. Can be used in conjunction with the \"include_null_first_air_dates\" filter if you want to include items with no air date.
        :param date first_air_date_lte: Filter and only include TV shows that have a original air date that is less than or equal to the specified value. Can be used in conjunction with the \"include_null_first_air_dates\" filter if you want to include items with no air date.
        :param int first_air_date_year: Filter and only include TV shows that have a original air date year that equal to the specified value. Can be used in conjunction with the \"include_null_first_air_dates\" filter if you want to include items with no air date.
        :param str language: Specify a language to query translatable fields with.
        :param int page: Specify the page of results to query.
        :param str timezone: Used in conjunction with the air_date.gte/lte filter to calculate the proper UTC offset.
        :param float vote_average_gte: Filter and only include movies that have a rating that is greater or equal to the specified value.
        :param int vote_count_gte: Filter and only include movies that have a rating that is less than or equal to the specified value.
        :param str with_genres: Comma separated value of genre ids that you want to include in the results.
        :param str with_networks: Comma separated value of network ids that you want to include in the results.
        :param str without_genres: Comma separated value of genre ids that you want to exclude from the results.
        :param int with_runtime_gte: Filter and only include TV shows with an episode runtime that is greater than or equal to a value.
        :param int with_runtime_lte: Filter and only include TV shows with an episode runtime that is less than or equal to a value.
        :param bool include_null_first_air_dates: Use this filter to include TV shows that don't have an air date while using any of the \"first_air_date\" filters.
        :param str with_original_language: Specify an ISO 639-1 string to filter results by their original language value.
        :param str without_keywords: Exclude items with certain keywords. You can comma and pipe seperate these values to create an 'AND' or 'OR' logic.
        :param bool screened_theatrically: Filter results to include items that have been screened theatrically.
        :param str with_companies: A comma separated list of production company ID's. Only include movies that have one of the ID's added as a production company.
        :param str with_keywords: A comma separated list of keyword ID's. Only includes TV shows that have one of the ID's added as a keyword.
        :return: InlineResponse20024
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['sort_by', 'air_date_gte', 'air_date_lte', 'first_air_date_gte', 'first_air_date_lte', 'first_air_date_year', 'language', 'page', 'timezone', 'vote_average_gte', 'vote_count_gte', 'with_genres', 'with_networks', 'without_genres', 'with_runtime_gte', 'with_runtime_lte', 'include_null_first_air_dates', 'with_original_language', 'without_keywords', 'screened_theatrically', 'with_companies', 'with_keywords']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method g_et_discover_tv" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501
        if 'air_date_gte' in params:
            query_params.append(('air_date.gte', params['air_date_gte']))  # noqa: E501
        if 'air_date_lte' in params:
            query_params.append(('air_date.lte', params['air_date_lte']))  # noqa: E501
        if 'first_air_date_gte' in params:
            query_params.append(('first_air_date.gte', params['first_air_date_gte']))  # noqa: E501
        if 'first_air_date_lte' in params:
            query_params.append(('first_air_date.lte', params['first_air_date_lte']))  # noqa: E501
        if 'first_air_date_year' in params:
            query_params.append(('first_air_date_year', params['first_air_date_year']))  # noqa: E501
        if 'language' in params:
            query_params.append(('language', params['language']))  # noqa: E501
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'timezone' in params:
            query_params.append(('timezone', params['timezone']))  # noqa: E501
        if 'vote_average_gte' in params:
            query_params.append(('vote_average.gte', params['vote_average_gte']))  # noqa: E501
        if 'vote_count_gte' in params:
            query_params.append(('vote_count.gte', params['vote_count_gte']))  # noqa: E501
        if 'with_genres' in params:
            query_params.append(('with_genres', params['with_genres']))  # noqa: E501
        if 'with_networks' in params:
            query_params.append(('with_networks', params['with_networks']))  # noqa: E501
        if 'without_genres' in params:
            query_params.append(('without_genres', params['without_genres']))  # noqa: E501
        if 'with_runtime_gte' in params:
            query_params.append(('with_runtime.gte', params['with_runtime_gte']))  # noqa: E501
        if 'with_runtime_lte' in params:
            query_params.append(('with_runtime.lte', params['with_runtime_lte']))  # noqa: E501
        if 'include_null_first_air_dates' in params:
            query_params.append(('include_null_first_air_dates', params['include_null_first_air_dates']))  # noqa: E501
        if 'with_original_language' in params:
            query_params.append(('with_original_language', params['with_original_language']))  # noqa: E501
        if 'without_keywords' in params:
            query_params.append(('without_keywords', params['without_keywords']))  # noqa: E501
        if 'screened_theatrically' in params:
            query_params.append(('screened_theatrically', params['screened_theatrically']))  # noqa: E501
        if 'with_companies' in params:
            query_params.append(('with_companies', params['with_companies']))  # noqa: E501
        if 'with_keywords' in params:
            query_params.append(('with_keywords', params['with_keywords']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/discover/tv', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20024',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def g_et_find_external_id(self, external_id, external_source, **kwargs):  # noqa: E501
        """Find by ID  # noqa: E501

        The find method makes it easy to search for objects in our database by an external id. For example, an IMDB ID.  This method will search all objects (movies, TV shows and people) and return the results in a single response.  The supported external sources for each object are as follows.  #### Media Databases  |              | Movies | TV Shows | TV Seasons | TV Episodes | People | | ------------ | ------ | -------- | ---------- | ----------- | ------ | | IMDb ID      |       |         |           |            |       | | TVDB ID      |       |         |           |            |       | | Freebase MID*|       |         |           |            |       | | Freebase ID* |       |         |           |            |       | | TVRage ID*   |       |         |           |            |       |  #### Social IDs  |              | Movies | TV Shows | TV Seasons | TV Episodes | People | | ------------ | ------ | -------- | ---------- | ----------- | ------ | | Facebook     |       |         |           |            |       | | Instagram    |       |         |           |            |       | | Twitter      |       |         |           |            |       |  *Defunct or no longer available as a service.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_find_external_id(external_id, external_source, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str external_id: (required)
        :param str external_source: (required)
        :return: InlineResponse20087
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.g_et_find_external_id_with_http_info(external_id, external_source, **kwargs)  # noqa: E501
        else:
            (data) = self.g_et_find_external_id_with_http_info(external_id, external_source, **kwargs)  # noqa: E501
            return data

    def g_et_find_external_id_with_http_info(self, external_id, external_source, **kwargs):  # noqa: E501
        """Find by ID  # noqa: E501

        The find method makes it easy to search for objects in our database by an external id. For example, an IMDB ID.  This method will search all objects (movies, TV shows and people) and return the results in a single response.  The supported external sources for each object are as follows.  #### Media Databases  |              | Movies | TV Shows | TV Seasons | TV Episodes | People | | ------------ | ------ | -------- | ---------- | ----------- | ------ | | IMDb ID      |       |         |           |            |       | | TVDB ID      |       |         |           |            |       | | Freebase MID*|       |         |           |            |       | | Freebase ID* |       |         |           |            |       | | TVRage ID*   |       |         |           |            |       |  #### Social IDs  |              | Movies | TV Shows | TV Seasons | TV Episodes | People | | ------------ | ------ | -------- | ---------- | ----------- | ------ | | Facebook     |       |         |           |            |       | | Instagram    |       |         |           |            |       | | Twitter      |       |         |           |            |       |  *Defunct or no longer available as a service.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_find_external_id_with_http_info(external_id, external_source, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str external_id: (required)
        :param str external_source: (required)
        :return: InlineResponse20087
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['external_id', 'external_source']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method g_et_find_external_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'external_id' is set
        if ('external_id' not in params or
                params['external_id'] is None):
            raise ValueError("Missing the required parameter `external_id` when calling `g_et_find_external_id`")  # noqa: E501
        # verify the required parameter 'external_source' is set
        if ('external_source' not in params or
                params['external_source'] is None):
            raise ValueError("Missing the required parameter `external_source` when calling `g_et_find_external_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'external_id' in params:
            path_params['external_id'] = params['external_id']  # noqa: E501

        query_params = []
        if 'external_source' in params:
            query_params.append(('external_source', params['external_source']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/find/{external_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20087',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def g_et_genre_movie_list(self, **kwargs):  # noqa: E501
        """Get Movie List  # noqa: E501

        Get the list of official genres for movies.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_genre_movie_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str language:
        :return: InlineResponse20068
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.g_et_genre_movie_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.g_et_genre_movie_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def g_et_genre_movie_list_with_http_info(self, **kwargs):  # noqa: E501
        """Get Movie List  # noqa: E501

        Get the list of official genres for movies.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_genre_movie_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str language:
        :return: InlineResponse20068
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['language']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method g_et_genre_movie_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'language' in params:
            query_params.append(('language', params['language']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/genre/movie/list', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20068',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def g_et_genre_tv_list(self, **kwargs):  # noqa: E501
        """Get TV List  # noqa: E501

        Get the list of official genres for TV shows.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_genre_tv_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse20068
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.g_et_genre_tv_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.g_et_genre_tv_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def g_et_genre_tv_list_with_http_info(self, **kwargs):  # noqa: E501
        """Get TV List  # noqa: E501

        Get the list of official genres for TV shows.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_genre_tv_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse20068
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method g_et_genre_tv_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/genre/tv/list', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20068',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def g_et_guest_session_guest_session_id_rated_movies(self, guest_session_id, **kwargs):  # noqa: E501
        """Get Rated Movies  # noqa: E501

        Get the rated movies for a guest session.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_guest_session_guest_session_id_rated_movies(guest_session_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str guest_session_id: (required)
        :return: InlineResponse20021
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.g_et_guest_session_guest_session_id_rated_movies_with_http_info(guest_session_id, **kwargs)  # noqa: E501
        else:
            (data) = self.g_et_guest_session_guest_session_id_rated_movies_with_http_info(guest_session_id, **kwargs)  # noqa: E501
            return data

    def g_et_guest_session_guest_session_id_rated_movies_with_http_info(self, guest_session_id, **kwargs):  # noqa: E501
        """Get Rated Movies  # noqa: E501

        Get the rated movies for a guest session.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_guest_session_guest_session_id_rated_movies_with_http_info(guest_session_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str guest_session_id: (required)
        :return: InlineResponse20021
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['guest_session_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method g_et_guest_session_guest_session_id_rated_movies" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'guest_session_id' is set
        if ('guest_session_id' not in params or
                params['guest_session_id'] is None):
            raise ValueError("Missing the required parameter `guest_session_id` when calling `g_et_guest_session_guest_session_id_rated_movies`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'guest_session_id' in params:
            path_params['guest_session_id'] = params['guest_session_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/guest_session/{guest_session_id}/rated/movies', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20021',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def g_et_guest_session_guest_session_id_rated_tv(self, guest_session_id, **kwargs):  # noqa: E501
        """Get Rated TV Shows  # noqa: E501

        Get the rated TV shows for a guest session.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_guest_session_guest_session_id_rated_tv(guest_session_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str guest_session_id: (required)
        :return: InlineResponse2008
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.g_et_guest_session_guest_session_id_rated_tv_with_http_info(guest_session_id, **kwargs)  # noqa: E501
        else:
            (data) = self.g_et_guest_session_guest_session_id_rated_tv_with_http_info(guest_session_id, **kwargs)  # noqa: E501
            return data

    def g_et_guest_session_guest_session_id_rated_tv_with_http_info(self, guest_session_id, **kwargs):  # noqa: E501
        """Get Rated TV Shows  # noqa: E501

        Get the rated TV shows for a guest session.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_guest_session_guest_session_id_rated_tv_with_http_info(guest_session_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str guest_session_id: (required)
        :return: InlineResponse2008
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['guest_session_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method g_et_guest_session_guest_session_id_rated_tv" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'guest_session_id' is set
        if ('guest_session_id' not in params or
                params['guest_session_id'] is None):
            raise ValueError("Missing the required parameter `guest_session_id` when calling `g_et_guest_session_guest_session_id_rated_tv`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'guest_session_id' in params:
            path_params['guest_session_id'] = params['guest_session_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/guest_session/{guest_session_id}/rated/tv', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2008',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def g_et_guest_session_guest_session_id_rated_tv_episodes(self, guest_session_id, **kwargs):  # noqa: E501
        """Get Rated TV Episodes  # noqa: E501

        Get the rated TV episodes for a guest session.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_guest_session_guest_session_id_rated_tv_episodes(guest_session_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str guest_session_id: (required)
        :return: InlineResponse20078
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.g_et_guest_session_guest_session_id_rated_tv_episodes_with_http_info(guest_session_id, **kwargs)  # noqa: E501
        else:
            (data) = self.g_et_guest_session_guest_session_id_rated_tv_episodes_with_http_info(guest_session_id, **kwargs)  # noqa: E501
            return data

    def g_et_guest_session_guest_session_id_rated_tv_episodes_with_http_info(self, guest_session_id, **kwargs):  # noqa: E501
        """Get Rated TV Episodes  # noqa: E501

        Get the rated TV episodes for a guest session.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_guest_session_guest_session_id_rated_tv_episodes_with_http_info(guest_session_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str guest_session_id: (required)
        :return: InlineResponse20078
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['guest_session_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method g_et_guest_session_guest_session_id_rated_tv_episodes" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'guest_session_id' is set
        if ('guest_session_id' not in params or
                params['guest_session_id'] is None):
            raise ValueError("Missing the required parameter `guest_session_id` when calling `g_et_guest_session_guest_session_id_rated_tv_episodes`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'guest_session_id' in params:
            path_params['guest_session_id'] = params['guest_session_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/guest_session/{guest_session_id}/rated/tv/episodes', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20078',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def g_et_keyword_keyword_id(self, keyword_id, **kwargs):  # noqa: E501
        """Get Details  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_keyword_keyword_id(keyword_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int keyword_id: (required)
        :return: InlineResponse20018Results
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.g_et_keyword_keyword_id_with_http_info(keyword_id, **kwargs)  # noqa: E501
        else:
            (data) = self.g_et_keyword_keyword_id_with_http_info(keyword_id, **kwargs)  # noqa: E501
            return data

    def g_et_keyword_keyword_id_with_http_info(self, keyword_id, **kwargs):  # noqa: E501
        """Get Details  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_keyword_keyword_id_with_http_info(keyword_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int keyword_id: (required)
        :return: InlineResponse20018Results
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['keyword_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method g_et_keyword_keyword_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'keyword_id' is set
        if ('keyword_id' not in params or
                params['keyword_id'] is None):
            raise ValueError("Missing the required parameter `keyword_id` when calling `g_et_keyword_keyword_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'keyword_id' in params:
            path_params['keyword_id'] = params['keyword_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/keyword/{keyword_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20018Results',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def g_et_keyword_keyword_id_movies(self, keyword_id, **kwargs):  # noqa: E501
        """Get Movies  # noqa: E501

        Get the movies that belong to a keyword.  We **highly recommend** using [movie discover](#endpoint:p5NyoR7dM842S8G9j) instead of this method as it is much more flexible.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_keyword_keyword_id_movies(keyword_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int keyword_id: (required)
        :return: InlineResponse20086
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.g_et_keyword_keyword_id_movies_with_http_info(keyword_id, **kwargs)  # noqa: E501
        else:
            (data) = self.g_et_keyword_keyword_id_movies_with_http_info(keyword_id, **kwargs)  # noqa: E501
            return data

    def g_et_keyword_keyword_id_movies_with_http_info(self, keyword_id, **kwargs):  # noqa: E501
        """Get Movies  # noqa: E501

        Get the movies that belong to a keyword.  We **highly recommend** using [movie discover](#endpoint:p5NyoR7dM842S8G9j) instead of this method as it is much more flexible.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_keyword_keyword_id_movies_with_http_info(keyword_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int keyword_id: (required)
        :return: InlineResponse20086
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['keyword_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method g_et_keyword_keyword_id_movies" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'keyword_id' is set
        if ('keyword_id' not in params or
                params['keyword_id'] is None):
            raise ValueError("Missing the required parameter `keyword_id` when calling `g_et_keyword_keyword_id_movies`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'keyword_id' in params:
            path_params['keyword_id'] = params['keyword_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/keyword/{keyword_id}/movies', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20086',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def g_et_list_list_id(self, list_id, **kwargs):  # noqa: E501
        """Get Details  # noqa: E501

        Get the details of a list.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_list_list_id(list_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str list_id: (required)
        :return: InlineResponse20038
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.g_et_list_list_id_with_http_info(list_id, **kwargs)  # noqa: E501
        else:
            (data) = self.g_et_list_list_id_with_http_info(list_id, **kwargs)  # noqa: E501
            return data

    def g_et_list_list_id_with_http_info(self, list_id, **kwargs):  # noqa: E501
        """Get Details  # noqa: E501

        Get the details of a list.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_list_list_id_with_http_info(list_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str list_id: (required)
        :return: InlineResponse20038
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['list_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method g_et_list_list_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'list_id' is set
        if ('list_id' not in params or
                params['list_id'] is None):
            raise ValueError("Missing the required parameter `list_id` when calling `g_et_list_list_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'list_id' in params:
            path_params['list_id'] = params['list_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/list/{list_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20038',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def g_et_list_list_id_item_status(self, list_id, movie_id, **kwargs):  # noqa: E501
        """Check Item Status  # noqa: E501

        You can use this method to check if a movie has already been added to the list.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_list_list_id_item_status(list_id, movie_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str list_id: (required)
        :param int movie_id: (required)
        :return: InlineResponse20039
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.g_et_list_list_id_item_status_with_http_info(list_id, movie_id, **kwargs)  # noqa: E501
        else:
            (data) = self.g_et_list_list_id_item_status_with_http_info(list_id, movie_id, **kwargs)  # noqa: E501
            return data

    def g_et_list_list_id_item_status_with_http_info(self, list_id, movie_id, **kwargs):  # noqa: E501
        """Check Item Status  # noqa: E501

        You can use this method to check if a movie has already been added to the list.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_list_list_id_item_status_with_http_info(list_id, movie_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str list_id: (required)
        :param int movie_id: (required)
        :return: InlineResponse20039
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['list_id', 'movie_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method g_et_list_list_id_item_status" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'list_id' is set
        if ('list_id' not in params or
                params['list_id'] is None):
            raise ValueError("Missing the required parameter `list_id` when calling `g_et_list_list_id_item_status`")  # noqa: E501
        # verify the required parameter 'movie_id' is set
        if ('movie_id' not in params or
                params['movie_id'] is None):
            raise ValueError("Missing the required parameter `movie_id` when calling `g_et_list_list_id_item_status`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'list_id' in params:
            path_params['list_id'] = params['list_id']  # noqa: E501

        query_params = []
        if 'movie_id' in params:
            query_params.append(('movie_id', params['movie_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/list/{list_id}/item_status', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20039',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def g_et_movie_changes(self, **kwargs):  # noqa: E501
        """Get Movie Change List  # noqa: E501

        Get  a list of all of the movie ids that have been changed in the past 24 hours.  You can query it for up to 14 days worth of changed IDs at a time with the `start_date` and `end_date` query parameters. 100 items are returned per page.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_movie_changes(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse2006
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.g_et_movie_changes_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.g_et_movie_changes_with_http_info(**kwargs)  # noqa: E501
            return data

    def g_et_movie_changes_with_http_info(self, **kwargs):  # noqa: E501
        """Get Movie Change List  # noqa: E501

        Get  a list of all of the movie ids that have been changed in the past 24 hours.  You can query it for up to 14 days worth of changed IDs at a time with the `start_date` and `end_date` query parameters. 100 items are returned per page.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_movie_changes_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse2006
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method g_et_movie_changes" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/movie/changes', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2006',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def g_et_movie_latest(self, **kwargs):  # noqa: E501
        """Get Latest  # noqa: E501

        Get the most newly created movie. This is a live response and will continuously change.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_movie_latest(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse20070
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.g_et_movie_latest_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.g_et_movie_latest_with_http_info(**kwargs)  # noqa: E501
            return data

    def g_et_movie_latest_with_http_info(self, **kwargs):  # noqa: E501
        """Get Latest  # noqa: E501

        Get the most newly created movie. This is a live response and will continuously change.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_movie_latest_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse20070
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method g_et_movie_latest" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/movie/latest', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20070',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def g_et_movie_movie_id(self, movie_id, **kwargs):  # noqa: E501
        """Get Details  # noqa: E501

        Get the primary information about a movie.  Supports `append_to_response`. Read more about this [here](#docTextSection:JdZq8ctmcxNqyLQjp).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_movie_movie_id(movie_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int movie_id: (required)
        :return: InlineResponse20050
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.g_et_movie_movie_id_with_http_info(movie_id, **kwargs)  # noqa: E501
        else:
            (data) = self.g_et_movie_movie_id_with_http_info(movie_id, **kwargs)  # noqa: E501
            return data

    def g_et_movie_movie_id_with_http_info(self, movie_id, **kwargs):  # noqa: E501
        """Get Details  # noqa: E501

        Get the primary information about a movie.  Supports `append_to_response`. Read more about this [here](#docTextSection:JdZq8ctmcxNqyLQjp).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_movie_movie_id_with_http_info(movie_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int movie_id: (required)
        :return: InlineResponse20050
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['movie_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method g_et_movie_movie_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'movie_id' is set
        if ('movie_id' not in params or
                params['movie_id'] is None):
            raise ValueError("Missing the required parameter `movie_id` when calling `g_et_movie_movie_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'movie_id' in params:
            path_params['movie_id'] = params['movie_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/movie/{movie_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20050',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def g_et_movie_movie_id_account_states(self, movie_id, **kwargs):  # noqa: E501
        """Get Account States  # noqa: E501

        Grab the following account states for a session:  - Movie rating - If it belongs to your watchlist - If it belongs to your favourite list  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_movie_movie_id_account_states(movie_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int movie_id: (required)
        :param str session_id:
        :param str guest_session_id:
        :return: InlineResponse20072
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.g_et_movie_movie_id_account_states_with_http_info(movie_id, **kwargs)  # noqa: E501
        else:
            (data) = self.g_et_movie_movie_id_account_states_with_http_info(movie_id, **kwargs)  # noqa: E501
            return data

    def g_et_movie_movie_id_account_states_with_http_info(self, movie_id, **kwargs):  # noqa: E501
        """Get Account States  # noqa: E501

        Grab the following account states for a session:  - Movie rating - If it belongs to your watchlist - If it belongs to your favourite list  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_movie_movie_id_account_states_with_http_info(movie_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int movie_id: (required)
        :param str session_id:
        :param str guest_session_id:
        :return: InlineResponse20072
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['movie_id', 'session_id', 'guest_session_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method g_et_movie_movie_id_account_states" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'movie_id' is set
        if ('movie_id' not in params or
                params['movie_id'] is None):
            raise ValueError("Missing the required parameter `movie_id` when calling `g_et_movie_movie_id_account_states`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'movie_id' in params:
            path_params['movie_id'] = params['movie_id']  # noqa: E501

        query_params = []
        if 'session_id' in params:
            query_params.append(('session_id', params['session_id']))  # noqa: E501
        if 'guest_session_id' in params:
            query_params.append(('guest_session_id', params['guest_session_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/movie/{movie_id}/account_states', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20072',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def g_et_movie_movie_id_alternative_titles(self, movie_id, **kwargs):  # noqa: E501
        """Get Alternative Titles  # noqa: E501

        Get all of the alternative titles for a movie.  #### Recent Changes  | **Date** | **Change** | | - | - | | March 16, 2018 | Added the `type` field. |  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_movie_movie_id_alternative_titles(movie_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int movie_id: (required)
        :param str country:
        :return: InlineResponse20066
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.g_et_movie_movie_id_alternative_titles_with_http_info(movie_id, **kwargs)  # noqa: E501
        else:
            (data) = self.g_et_movie_movie_id_alternative_titles_with_http_info(movie_id, **kwargs)  # noqa: E501
            return data

    def g_et_movie_movie_id_alternative_titles_with_http_info(self, movie_id, **kwargs):  # noqa: E501
        """Get Alternative Titles  # noqa: E501

        Get all of the alternative titles for a movie.  #### Recent Changes  | **Date** | **Change** | | - | - | | March 16, 2018 | Added the `type` field. |  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_movie_movie_id_alternative_titles_with_http_info(movie_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int movie_id: (required)
        :param str country:
        :return: InlineResponse20066
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['movie_id', 'country']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method g_et_movie_movie_id_alternative_titles" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'movie_id' is set
        if ('movie_id' not in params or
                params['movie_id'] is None):
            raise ValueError("Missing the required parameter `movie_id` when calling `g_et_movie_movie_id_alternative_titles`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'movie_id' in params:
            path_params['movie_id'] = params['movie_id']  # noqa: E501

        query_params = []
        if 'country' in params:
            query_params.append(('country', params['country']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/movie/{movie_id}/alternative_titles', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20066',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def g_et_movie_movie_id_changes(self, movie_id, **kwargs):  # noqa: E501
        """Get Changes  # noqa: E501

        Get the changes for a movie. By default only the last 24 hours are returned.  You can query up to 14 days in a single query by using the `start_date` and `end_date` query parameters.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_movie_movie_id_changes(movie_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int movie_id: (required)
        :return: InlineResponse2002
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.g_et_movie_movie_id_changes_with_http_info(movie_id, **kwargs)  # noqa: E501
        else:
            (data) = self.g_et_movie_movie_id_changes_with_http_info(movie_id, **kwargs)  # noqa: E501
            return data

    def g_et_movie_movie_id_changes_with_http_info(self, movie_id, **kwargs):  # noqa: E501
        """Get Changes  # noqa: E501

        Get the changes for a movie. By default only the last 24 hours are returned.  You can query up to 14 days in a single query by using the `start_date` and `end_date` query parameters.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_movie_movie_id_changes_with_http_info(movie_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int movie_id: (required)
        :return: InlineResponse2002
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['movie_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method g_et_movie_movie_id_changes" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'movie_id' is set
        if ('movie_id' not in params or
                params['movie_id'] is None):
            raise ValueError("Missing the required parameter `movie_id` when calling `g_et_movie_movie_id_changes`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'movie_id' in params:
            path_params['movie_id'] = params['movie_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/movie/{movie_id}/changes', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2002',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def g_et_movie_movie_id_credits(self, movie_id, **kwargs):  # noqa: E501
        """Get Credits  # noqa: E501

        Get the cast and crew for a movie.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_movie_movie_id_credits(movie_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int movie_id: (required)
        :return: InlineResponse20091
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.g_et_movie_movie_id_credits_with_http_info(movie_id, **kwargs)  # noqa: E501
        else:
            (data) = self.g_et_movie_movie_id_credits_with_http_info(movie_id, **kwargs)  # noqa: E501
            return data

    def g_et_movie_movie_id_credits_with_http_info(self, movie_id, **kwargs):  # noqa: E501
        """Get Credits  # noqa: E501

        Get the cast and crew for a movie.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_movie_movie_id_credits_with_http_info(movie_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int movie_id: (required)
        :return: InlineResponse20091
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['movie_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method g_et_movie_movie_id_credits" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'movie_id' is set
        if ('movie_id' not in params or
                params['movie_id'] is None):
            raise ValueError("Missing the required parameter `movie_id` when calling `g_et_movie_movie_id_credits`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'movie_id' in params:
            path_params['movie_id'] = params['movie_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/movie/{movie_id}/credits', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20091',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def g_et_movie_movie_id_external_ids(self, movie_id, **kwargs):  # noqa: E501
        """Get External IDs  # noqa: E501

        Get the external ids for a movie. We currently support the following external sources.  | **Media Databases** | **Social IDs** | | ------------------- | -------------- | | IMDb ID             | Facebook       | |                     | Instagram      | |                     | Twitter        |  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_movie_movie_id_external_ids(movie_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int movie_id: (required)
        :param str api_key:
        :return: InlineResponse20010
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.g_et_movie_movie_id_external_ids_with_http_info(movie_id, **kwargs)  # noqa: E501
        else:
            (data) = self.g_et_movie_movie_id_external_ids_with_http_info(movie_id, **kwargs)  # noqa: E501
            return data

    def g_et_movie_movie_id_external_ids_with_http_info(self, movie_id, **kwargs):  # noqa: E501
        """Get External IDs  # noqa: E501

        Get the external ids for a movie. We currently support the following external sources.  | **Media Databases** | **Social IDs** | | ------------------- | -------------- | | IMDb ID             | Facebook       | |                     | Instagram      | |                     | Twitter        |  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_movie_movie_id_external_ids_with_http_info(movie_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int movie_id: (required)
        :param str api_key:
        :return: InlineResponse20010
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['movie_id', 'api_key']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method g_et_movie_movie_id_external_ids" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'movie_id' is set
        if ('movie_id' not in params or
                params['movie_id'] is None):
            raise ValueError("Missing the required parameter `movie_id` when calling `g_et_movie_movie_id_external_ids`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'movie_id' in params:
            path_params['movie_id'] = params['movie_id']  # noqa: E501

        query_params = []
        if 'api_key' in params:
            query_params.append(('api_key', params['api_key']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/movie/{movie_id}/external_ids', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20010',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def g_et_movie_movie_id_images(self, movie_id, **kwargs):  # noqa: E501
        """Get Images  # noqa: E501

        Get the images that belong to a movie.  Querying images with a `language` parameter will filter the results. If you want to include a fallback language (especially useful for backdrops) you can use the `include_image_language` parameter. This should be a comma seperated value like so: `include_image_language=en,null`.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_movie_movie_id_images(movie_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int movie_id: (required)
        :param str include_image_language:
        :return: InlineResponse20031
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.g_et_movie_movie_id_images_with_http_info(movie_id, **kwargs)  # noqa: E501
        else:
            (data) = self.g_et_movie_movie_id_images_with_http_info(movie_id, **kwargs)  # noqa: E501
            return data

    def g_et_movie_movie_id_images_with_http_info(self, movie_id, **kwargs):  # noqa: E501
        """Get Images  # noqa: E501

        Get the images that belong to a movie.  Querying images with a `language` parameter will filter the results. If you want to include a fallback language (especially useful for backdrops) you can use the `include_image_language` parameter. This should be a comma seperated value like so: `include_image_language=en,null`.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_movie_movie_id_images_with_http_info(movie_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int movie_id: (required)
        :param str include_image_language:
        :return: InlineResponse20031
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['movie_id', 'include_image_language']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method g_et_movie_movie_id_images" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'movie_id' is set
        if ('movie_id' not in params or
                params['movie_id'] is None):
            raise ValueError("Missing the required parameter `movie_id` when calling `g_et_movie_movie_id_images`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'movie_id' in params:
            path_params['movie_id'] = params['movie_id']  # noqa: E501

        query_params = []
        if 'include_image_language' in params:
            query_params.append(('include_image_language', params['include_image_language']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/movie/{movie_id}/images', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20031',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def g_et_movie_movie_id_keywords(self, movie_id, **kwargs):  # noqa: E501
        """Get Keywords  # noqa: E501

        Get the keywords that have been added to a movie.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_movie_movie_id_keywords(movie_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int movie_id: (required)
        :param str api_key:
        :return: InlineResponse20077
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.g_et_movie_movie_id_keywords_with_http_info(movie_id, **kwargs)  # noqa: E501
        else:
            (data) = self.g_et_movie_movie_id_keywords_with_http_info(movie_id, **kwargs)  # noqa: E501
            return data

    def g_et_movie_movie_id_keywords_with_http_info(self, movie_id, **kwargs):  # noqa: E501
        """Get Keywords  # noqa: E501

        Get the keywords that have been added to a movie.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_movie_movie_id_keywords_with_http_info(movie_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int movie_id: (required)
        :param str api_key:
        :return: InlineResponse20077
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['movie_id', 'api_key']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method g_et_movie_movie_id_keywords" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'movie_id' is set
        if ('movie_id' not in params or
                params['movie_id'] is None):
            raise ValueError("Missing the required parameter `movie_id` when calling `g_et_movie_movie_id_keywords`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'movie_id' in params:
            path_params['movie_id'] = params['movie_id']  # noqa: E501

        query_params = []
        if 'api_key' in params:
            query_params.append(('api_key', params['api_key']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/movie/{movie_id}/keywords', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20077',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def g_et_movie_movie_id_lists(self, movie_id, **kwargs):  # noqa: E501
        """Get Lists  # noqa: E501

        Get a list of lists that this movie belongs to.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_movie_movie_id_lists(movie_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int movie_id: (required)
        :param str api_key:
        :return: InlineResponse20061
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.g_et_movie_movie_id_lists_with_http_info(movie_id, **kwargs)  # noqa: E501
        else:
            (data) = self.g_et_movie_movie_id_lists_with_http_info(movie_id, **kwargs)  # noqa: E501
            return data

    def g_et_movie_movie_id_lists_with_http_info(self, movie_id, **kwargs):  # noqa: E501
        """Get Lists  # noqa: E501

        Get a list of lists that this movie belongs to.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_movie_movie_id_lists_with_http_info(movie_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int movie_id: (required)
        :param str api_key:
        :return: InlineResponse20061
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['movie_id', 'api_key']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method g_et_movie_movie_id_lists" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'movie_id' is set
        if ('movie_id' not in params or
                params['movie_id'] is None):
            raise ValueError("Missing the required parameter `movie_id` when calling `g_et_movie_movie_id_lists`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'movie_id' in params:
            path_params['movie_id'] = params['movie_id']  # noqa: E501

        query_params = []
        if 'api_key' in params:
            query_params.append(('api_key', params['api_key']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/movie/{movie_id}/lists', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20061',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def g_et_movie_movie_id_recommendations(self, movie_id, **kwargs):  # noqa: E501
        """Get Recommendations  # noqa: E501

        Get a list of recommended movies for a movie.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_movie_movie_id_recommendations(movie_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int movie_id: (required)
        :param str api_key:
        :return: InlineResponse2001
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.g_et_movie_movie_id_recommendations_with_http_info(movie_id, **kwargs)  # noqa: E501
        else:
            (data) = self.g_et_movie_movie_id_recommendations_with_http_info(movie_id, **kwargs)  # noqa: E501
            return data

    def g_et_movie_movie_id_recommendations_with_http_info(self, movie_id, **kwargs):  # noqa: E501
        """Get Recommendations  # noqa: E501

        Get a list of recommended movies for a movie.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_movie_movie_id_recommendations_with_http_info(movie_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int movie_id: (required)
        :param str api_key:
        :return: InlineResponse2001
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['movie_id', 'api_key']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method g_et_movie_movie_id_recommendations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'movie_id' is set
        if ('movie_id' not in params or
                params['movie_id'] is None):
            raise ValueError("Missing the required parameter `movie_id` when calling `g_et_movie_movie_id_recommendations`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'movie_id' in params:
            path_params['movie_id'] = params['movie_id']  # noqa: E501

        query_params = []
        if 'api_key' in params:
            query_params.append(('api_key', params['api_key']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/movie/{movie_id}/recommendations', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2001',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def g_et_movie_movie_id_release_dates(self, movie_id, **kwargs):  # noqa: E501
        """Get Release Dates  # noqa: E501

        Get the release date along with the certification for a movie.  Release dates support different types:  1. Premiere 2. Theatrical (limited) 3. Theatrical 4. Digital 5. Physical 6. TV  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_movie_movie_id_release_dates(movie_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int movie_id: (required)
        :param str api_key:
        :return: InlineResponse20059
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.g_et_movie_movie_id_release_dates_with_http_info(movie_id, **kwargs)  # noqa: E501
        else:
            (data) = self.g_et_movie_movie_id_release_dates_with_http_info(movie_id, **kwargs)  # noqa: E501
            return data

    def g_et_movie_movie_id_release_dates_with_http_info(self, movie_id, **kwargs):  # noqa: E501
        """Get Release Dates  # noqa: E501

        Get the release date along with the certification for a movie.  Release dates support different types:  1. Premiere 2. Theatrical (limited) 3. Theatrical 4. Digital 5. Physical 6. TV  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_movie_movie_id_release_dates_with_http_info(movie_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int movie_id: (required)
        :param str api_key:
        :return: InlineResponse20059
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['movie_id', 'api_key']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method g_et_movie_movie_id_release_dates" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'movie_id' is set
        if ('movie_id' not in params or
                params['movie_id'] is None):
            raise ValueError("Missing the required parameter `movie_id` when calling `g_et_movie_movie_id_release_dates`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'movie_id' in params:
            path_params['movie_id'] = params['movie_id']  # noqa: E501

        query_params = []
        if 'api_key' in params:
            query_params.append(('api_key', params['api_key']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/movie/{movie_id}/release_dates', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20059',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def g_et_movie_movie_id_reviews(self, movie_id, **kwargs):  # noqa: E501
        """Get Reviews  # noqa: E501

        Get the user reviews for a movie.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_movie_movie_id_reviews(movie_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int movie_id: (required)
        :param str api_key:
        :return: InlineResponse20094
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.g_et_movie_movie_id_reviews_with_http_info(movie_id, **kwargs)  # noqa: E501
        else:
            (data) = self.g_et_movie_movie_id_reviews_with_http_info(movie_id, **kwargs)  # noqa: E501
            return data

    def g_et_movie_movie_id_reviews_with_http_info(self, movie_id, **kwargs):  # noqa: E501
        """Get Reviews  # noqa: E501

        Get the user reviews for a movie.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_movie_movie_id_reviews_with_http_info(movie_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int movie_id: (required)
        :param str api_key:
        :return: InlineResponse20094
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['movie_id', 'api_key']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method g_et_movie_movie_id_reviews" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'movie_id' is set
        if ('movie_id' not in params or
                params['movie_id'] is None):
            raise ValueError("Missing the required parameter `movie_id` when calling `g_et_movie_movie_id_reviews`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'movie_id' in params:
            path_params['movie_id'] = params['movie_id']  # noqa: E501

        query_params = []
        if 'api_key' in params:
            query_params.append(('api_key', params['api_key']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/movie/{movie_id}/reviews', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20094',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def g_et_movie_movie_id_similar(self, movie_id, **kwargs):  # noqa: E501
        """Get Similar Movies  # noqa: E501

        Get a list of similar movies. This is **not** the same as the \"Recommendation\" system you see on the website.  These items are assembled by looking at keywords and genres.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_movie_movie_id_similar(movie_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int movie_id: (required)
        :param str api_key:
        :return: InlineResponse2001
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.g_et_movie_movie_id_similar_with_http_info(movie_id, **kwargs)  # noqa: E501
        else:
            (data) = self.g_et_movie_movie_id_similar_with_http_info(movie_id, **kwargs)  # noqa: E501
            return data

    def g_et_movie_movie_id_similar_with_http_info(self, movie_id, **kwargs):  # noqa: E501
        """Get Similar Movies  # noqa: E501

        Get a list of similar movies. This is **not** the same as the \"Recommendation\" system you see on the website.  These items are assembled by looking at keywords and genres.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_movie_movie_id_similar_with_http_info(movie_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int movie_id: (required)
        :param str api_key:
        :return: InlineResponse2001
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['movie_id', 'api_key']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method g_et_movie_movie_id_similar" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'movie_id' is set
        if ('movie_id' not in params or
                params['movie_id'] is None):
            raise ValueError("Missing the required parameter `movie_id` when calling `g_et_movie_movie_id_similar`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'movie_id' in params:
            path_params['movie_id'] = params['movie_id']  # noqa: E501

        query_params = []
        if 'api_key' in params:
            query_params.append(('api_key', params['api_key']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/movie/{movie_id}/similar', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2001',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def g_et_movie_movie_id_translations(self, movie_id, **kwargs):  # noqa: E501
        """Get Translations  # noqa: E501

        Get a list of translations that have been created for a movie.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_movie_movie_id_translations(movie_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int movie_id: (required)
        :param str api_key:
        :return: InlineResponse20043
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.g_et_movie_movie_id_translations_with_http_info(movie_id, **kwargs)  # noqa: E501
        else:
            (data) = self.g_et_movie_movie_id_translations_with_http_info(movie_id, **kwargs)  # noqa: E501
            return data

    def g_et_movie_movie_id_translations_with_http_info(self, movie_id, **kwargs):  # noqa: E501
        """Get Translations  # noqa: E501

        Get a list of translations that have been created for a movie.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_movie_movie_id_translations_with_http_info(movie_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int movie_id: (required)
        :param str api_key:
        :return: InlineResponse20043
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['movie_id', 'api_key']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method g_et_movie_movie_id_translations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'movie_id' is set
        if ('movie_id' not in params or
                params['movie_id'] is None):
            raise ValueError("Missing the required parameter `movie_id` when calling `g_et_movie_movie_id_translations`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'movie_id' in params:
            path_params['movie_id'] = params['movie_id']  # noqa: E501

        query_params = []
        if 'api_key' in params:
            query_params.append(('api_key', params['api_key']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/movie/{movie_id}/translations', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20043',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def g_et_movie_movie_id_videos(self, movie_id, **kwargs):  # noqa: E501
        """Get Videos  # noqa: E501

        Get the videos that have been added to a movie.  #### Recent Changes  | **Date** | **Change** | | - | - | | March 23, 2019 | Vimeo was added as a video source. | | March 20, 2019 | \"Behind the Scenes\" and \"Bloopers\" were added as valid video types. |  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_movie_movie_id_videos(movie_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int movie_id: (required)
        :param str api_key:
        :return: InlineResponse20017
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.g_et_movie_movie_id_videos_with_http_info(movie_id, **kwargs)  # noqa: E501
        else:
            (data) = self.g_et_movie_movie_id_videos_with_http_info(movie_id, **kwargs)  # noqa: E501
            return data

    def g_et_movie_movie_id_videos_with_http_info(self, movie_id, **kwargs):  # noqa: E501
        """Get Videos  # noqa: E501

        Get the videos that have been added to a movie.  #### Recent Changes  | **Date** | **Change** | | - | - | | March 23, 2019 | Vimeo was added as a video source. | | March 20, 2019 | \"Behind the Scenes\" and \"Bloopers\" were added as valid video types. |  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_movie_movie_id_videos_with_http_info(movie_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int movie_id: (required)
        :param str api_key:
        :return: InlineResponse20017
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['movie_id', 'api_key']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method g_et_movie_movie_id_videos" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'movie_id' is set
        if ('movie_id' not in params or
                params['movie_id'] is None):
            raise ValueError("Missing the required parameter `movie_id` when calling `g_et_movie_movie_id_videos`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'movie_id' in params:
            path_params['movie_id'] = params['movie_id']  # noqa: E501

        query_params = []
        if 'api_key' in params:
            query_params.append(('api_key', params['api_key']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/movie/{movie_id}/videos', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20017',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def g_et_movie_now_playing(self, **kwargs):  # noqa: E501
        """Get Now Playing  # noqa: E501

        Get a list of movies in theatres. This is a release type query that looks for all movies that have a release type of 2 or 3 within the specified date range.  You can optionally specify a `region` prameter which will narrow the search to only look for theatrical release dates within the specified country.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_movie_now_playing(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse20056
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.g_et_movie_now_playing_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.g_et_movie_now_playing_with_http_info(**kwargs)  # noqa: E501
            return data

    def g_et_movie_now_playing_with_http_info(self, **kwargs):  # noqa: E501
        """Get Now Playing  # noqa: E501

        Get a list of movies in theatres. This is a release type query that looks for all movies that have a release type of 2 or 3 within the specified date range.  You can optionally specify a `region` prameter which will narrow the search to only look for theatrical release dates within the specified country.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_movie_now_playing_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse20056
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method g_et_movie_now_playing" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/movie/now_playing', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20056',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def g_et_movie_popular(self, **kwargs):  # noqa: E501
        """Get Popular  # noqa: E501

        Get a list of the current popular movies on TMDb. This list updates daily.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_movie_popular(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse20027
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.g_et_movie_popular_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.g_et_movie_popular_with_http_info(**kwargs)  # noqa: E501
            return data

    def g_et_movie_popular_with_http_info(self, **kwargs):  # noqa: E501
        """Get Popular  # noqa: E501

        Get a list of the current popular movies on TMDb. This list updates daily.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_movie_popular_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse20027
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method g_et_movie_popular" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/movie/popular', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20027',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def g_et_movie_top_rated(self, **kwargs):  # noqa: E501
        """Get Top Rated  # noqa: E501

        Get the top rated movies on TMDb.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_movie_top_rated(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse20027
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.g_et_movie_top_rated_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.g_et_movie_top_rated_with_http_info(**kwargs)  # noqa: E501
            return data

    def g_et_movie_top_rated_with_http_info(self, **kwargs):  # noqa: E501
        """Get Top Rated  # noqa: E501

        Get the top rated movies on TMDb.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_movie_top_rated_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse20027
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method g_et_movie_top_rated" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/movie/top_rated', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20027',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def g_et_movie_upcoming(self, **kwargs):  # noqa: E501
        """Get Upcoming  # noqa: E501

        Get a list of upcoming movies in theatres. This is a release type query that looks for all movies that have a release type of 2 or 3 within the specified date range.  You can optionally specify a `region` prameter which will narrow the search to only look for theatrical release dates within the specified country.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_movie_upcoming(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse20041
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.g_et_movie_upcoming_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.g_et_movie_upcoming_with_http_info(**kwargs)  # noqa: E501
            return data

    def g_et_movie_upcoming_with_http_info(self, **kwargs):  # noqa: E501
        """Get Upcoming  # noqa: E501

        Get a list of upcoming movies in theatres. This is a release type query that looks for all movies that have a release type of 2 or 3 within the specified date range.  You can optionally specify a `region` prameter which will narrow the search to only look for theatrical release dates within the specified country.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_movie_upcoming_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse20041
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method g_et_movie_upcoming" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/movie/upcoming', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20041',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def g_et_network_network_id(self, network_id, **kwargs):  # noqa: E501
        """Get Details  # noqa: E501

        Get the details of a network.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_network_network_id(network_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int network_id: (required)
        :return: InlineResponse20029
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.g_et_network_network_id_with_http_info(network_id, **kwargs)  # noqa: E501
        else:
            (data) = self.g_et_network_network_id_with_http_info(network_id, **kwargs)  # noqa: E501
            return data

    def g_et_network_network_id_with_http_info(self, network_id, **kwargs):  # noqa: E501
        """Get Details  # noqa: E501

        Get the details of a network.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_network_network_id_with_http_info(network_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int network_id: (required)
        :return: InlineResponse20029
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['network_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method g_et_network_network_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'network_id' is set
        if ('network_id' not in params or
                params['network_id'] is None):
            raise ValueError("Missing the required parameter `network_id` when calling `g_et_network_network_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'network_id' in params:
            path_params['network_id'] = params['network_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/network/{network_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20029',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def g_et_network_network_id_alternative_names(self, network_id, **kwargs):  # noqa: E501
        """Get Alternative Names  # noqa: E501

        Get the alternative names of a network.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_network_network_id_alternative_names(network_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int network_id: (required)
        :return: InlineResponse20040
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.g_et_network_network_id_alternative_names_with_http_info(network_id, **kwargs)  # noqa: E501
        else:
            (data) = self.g_et_network_network_id_alternative_names_with_http_info(network_id, **kwargs)  # noqa: E501
            return data

    def g_et_network_network_id_alternative_names_with_http_info(self, network_id, **kwargs):  # noqa: E501
        """Get Alternative Names  # noqa: E501

        Get the alternative names of a network.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_network_network_id_alternative_names_with_http_info(network_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int network_id: (required)
        :return: InlineResponse20040
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['network_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method g_et_network_network_id_alternative_names" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'network_id' is set
        if ('network_id' not in params or
                params['network_id'] is None):
            raise ValueError("Missing the required parameter `network_id` when calling `g_et_network_network_id_alternative_names`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'network_id' in params:
            path_params['network_id'] = params['network_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/network/{network_id}/alternative_names', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20040',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def g_et_network_network_id_images(self, network_id, **kwargs):  # noqa: E501
        """Get Images  # noqa: E501

        Get the TV network logos by id.  There are two image formats that are supported for networks, PNG's and SVG's. You can see which type the original file is by looking at the `file_type` field. We prefer SVG's as they are resolution independent and as such, the width and height are only there to reflect the original asset that was uploaded. An SVG can be scaled properly beyond those dimensions if you call them as a PNG.  For more information about how SVG's and PNG's can be used, take a read through [this document](#docTextSection:mXP9B2uzoDJFguDZv).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_network_network_id_images(network_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int network_id: (required)
        :return: InlineResponse20023
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.g_et_network_network_id_images_with_http_info(network_id, **kwargs)  # noqa: E501
        else:
            (data) = self.g_et_network_network_id_images_with_http_info(network_id, **kwargs)  # noqa: E501
            return data

    def g_et_network_network_id_images_with_http_info(self, network_id, **kwargs):  # noqa: E501
        """Get Images  # noqa: E501

        Get the TV network logos by id.  There are two image formats that are supported for networks, PNG's and SVG's. You can see which type the original file is by looking at the `file_type` field. We prefer SVG's as they are resolution independent and as such, the width and height are only there to reflect the original asset that was uploaded. An SVG can be scaled properly beyond those dimensions if you call them as a PNG.  For more information about how SVG's and PNG's can be used, take a read through [this document](#docTextSection:mXP9B2uzoDJFguDZv).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_network_network_id_images_with_http_info(network_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int network_id: (required)
        :return: InlineResponse20023
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['network_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method g_et_network_network_id_images" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'network_id' is set
        if ('network_id' not in params or
                params['network_id'] is None):
            raise ValueError("Missing the required parameter `network_id` when calling `g_et_network_network_id_images`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'network_id' in params:
            path_params['network_id'] = params['network_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/network/{network_id}/images', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20023',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def g_et_person_changes(self, **kwargs):  # noqa: E501
        """Get Person Change List  # noqa: E501

        Get a list of all of the person ids that have been changed in the past 24 hours.  You can query it for up to 14 days worth of changed IDs at a time with the `start_date` and `end_date` query parameters. 100 items are returned per page.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_person_changes(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse2006
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.g_et_person_changes_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.g_et_person_changes_with_http_info(**kwargs)  # noqa: E501
            return data

    def g_et_person_changes_with_http_info(self, **kwargs):  # noqa: E501
        """Get Person Change List  # noqa: E501

        Get a list of all of the person ids that have been changed in the past 24 hours.  You can query it for up to 14 days worth of changed IDs at a time with the `start_date` and `end_date` query parameters. 100 items are returned per page.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_person_changes_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse2006
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method g_et_person_changes" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/person/changes', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2006',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def g_et_person_latest(self, **kwargs):  # noqa: E501
        """Get Latest  # noqa: E501

        Get the most newly created person. This is a live response and will continuously change.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_person_latest(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse20035
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.g_et_person_latest_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.g_et_person_latest_with_http_info(**kwargs)  # noqa: E501
            return data

    def g_et_person_latest_with_http_info(self, **kwargs):  # noqa: E501
        """Get Latest  # noqa: E501

        Get the most newly created person. This is a live response and will continuously change.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_person_latest_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse20035
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method g_et_person_latest" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/person/latest', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20035',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def g_et_person_person_id(self, person_id, **kwargs):  # noqa: E501
        """Get Details  # noqa: E501

        Get the primary person details by id.  Supports `append_to_response`. Read more about this [here](#docTextSection:JdZq8ctmcxNqyLQjp).  #### Recent Changes  | **Date** | **Change** | | - | - | | July 17, 2018 | Added the `known_for_department` field. | | April 26, 2018 | Added the [translations](#endpoint:CSaMjCxXAtGpxNGfS) method. | | November 9, 2016 | Biographies are now translatable on TMDb. This means you can query person details with a language parameter. |  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_person_person_id(person_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int person_id: (required)
        :return: InlineResponse2005
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.g_et_person_person_id_with_http_info(person_id, **kwargs)  # noqa: E501
        else:
            (data) = self.g_et_person_person_id_with_http_info(person_id, **kwargs)  # noqa: E501
            return data

    def g_et_person_person_id_with_http_info(self, person_id, **kwargs):  # noqa: E501
        """Get Details  # noqa: E501

        Get the primary person details by id.  Supports `append_to_response`. Read more about this [here](#docTextSection:JdZq8ctmcxNqyLQjp).  #### Recent Changes  | **Date** | **Change** | | - | - | | July 17, 2018 | Added the `known_for_department` field. | | April 26, 2018 | Added the [translations](#endpoint:CSaMjCxXAtGpxNGfS) method. | | November 9, 2016 | Biographies are now translatable on TMDb. This means you can query person details with a language parameter. |  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_person_person_id_with_http_info(person_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int person_id: (required)
        :return: InlineResponse2005
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['person_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method g_et_person_person_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'person_id' is set
        if ('person_id' not in params or
                params['person_id'] is None):
            raise ValueError("Missing the required parameter `person_id` when calling `g_et_person_person_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'person_id' in params:
            path_params['person_id'] = params['person_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/person/{person_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2005',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def g_et_person_person_id_changes(self, person_id, **kwargs):  # noqa: E501
        """Get Changes  # noqa: E501

        Get the changes for a person. By default only the last 24 hours are returned.  You can query up to 14 days in a single query by using the `start_date` and `end_date` query parameters.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_person_person_id_changes(person_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int person_id: (required)
        :return: InlineResponse20090
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.g_et_person_person_id_changes_with_http_info(person_id, **kwargs)  # noqa: E501
        else:
            (data) = self.g_et_person_person_id_changes_with_http_info(person_id, **kwargs)  # noqa: E501
            return data

    def g_et_person_person_id_changes_with_http_info(self, person_id, **kwargs):  # noqa: E501
        """Get Changes  # noqa: E501

        Get the changes for a person. By default only the last 24 hours are returned.  You can query up to 14 days in a single query by using the `start_date` and `end_date` query parameters.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_person_person_id_changes_with_http_info(person_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int person_id: (required)
        :return: InlineResponse20090
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['person_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method g_et_person_person_id_changes" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'person_id' is set
        if ('person_id' not in params or
                params['person_id'] is None):
            raise ValueError("Missing the required parameter `person_id` when calling `g_et_person_person_id_changes`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'person_id' in params:
            path_params['person_id'] = params['person_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/person/{person_id}/changes', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20090',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def g_et_person_person_id_combined_credits(self, person_id, **kwargs):  # noqa: E501
        """Get Combined Credits  # noqa: E501

        Get the movie and TV credits together in a single response.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_person_person_id_combined_credits(person_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int person_id: (required)
        :return: InlineResponse20084
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.g_et_person_person_id_combined_credits_with_http_info(person_id, **kwargs)  # noqa: E501
        else:
            (data) = self.g_et_person_person_id_combined_credits_with_http_info(person_id, **kwargs)  # noqa: E501
            return data

    def g_et_person_person_id_combined_credits_with_http_info(self, person_id, **kwargs):  # noqa: E501
        """Get Combined Credits  # noqa: E501

        Get the movie and TV credits together in a single response.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_person_person_id_combined_credits_with_http_info(person_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int person_id: (required)
        :return: InlineResponse20084
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['person_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method g_et_person_person_id_combined_credits" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'person_id' is set
        if ('person_id' not in params or
                params['person_id'] is None):
            raise ValueError("Missing the required parameter `person_id` when calling `g_et_person_person_id_combined_credits`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'person_id' in params:
            path_params['person_id'] = params['person_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/person/{person_id}/combined_credits', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20084',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def g_et_person_person_id_external_ids(self, person_id, **kwargs):  # noqa: E501
        """Get External IDs  # noqa: E501

        Get the external ids for a person. We currently support the following external sources.  | **External Sources** | | ------------     | | IMDB ID          | | Facebook         | | Freebase MID     | | Freebase ID      | | Instagram        | | TVRage ID        | | Twitter          |  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_person_person_id_external_ids(person_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int person_id: (required)
        :return: InlineResponse20058
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.g_et_person_person_id_external_ids_with_http_info(person_id, **kwargs)  # noqa: E501
        else:
            (data) = self.g_et_person_person_id_external_ids_with_http_info(person_id, **kwargs)  # noqa: E501
            return data

    def g_et_person_person_id_external_ids_with_http_info(self, person_id, **kwargs):  # noqa: E501
        """Get External IDs  # noqa: E501

        Get the external ids for a person. We currently support the following external sources.  | **External Sources** | | ------------     | | IMDB ID          | | Facebook         | | Freebase MID     | | Freebase ID      | | Instagram        | | TVRage ID        | | Twitter          |  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_person_person_id_external_ids_with_http_info(person_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int person_id: (required)
        :return: InlineResponse20058
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['person_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method g_et_person_person_id_external_ids" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'person_id' is set
        if ('person_id' not in params or
                params['person_id'] is None):
            raise ValueError("Missing the required parameter `person_id` when calling `g_et_person_person_id_external_ids`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'person_id' in params:
            path_params['person_id'] = params['person_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/person/{person_id}/external_ids', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20058',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def g_et_person_person_id_images(self, person_id, **kwargs):  # noqa: E501
        """Get Images  # noqa: E501

        Get the images for a person.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_person_person_id_images(person_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int person_id: (required)
        :return: InlineResponse20064
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.g_et_person_person_id_images_with_http_info(person_id, **kwargs)  # noqa: E501
        else:
            (data) = self.g_et_person_person_id_images_with_http_info(person_id, **kwargs)  # noqa: E501
            return data

    def g_et_person_person_id_images_with_http_info(self, person_id, **kwargs):  # noqa: E501
        """Get Images  # noqa: E501

        Get the images for a person.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_person_person_id_images_with_http_info(person_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int person_id: (required)
        :return: InlineResponse20064
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['person_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method g_et_person_person_id_images" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'person_id' is set
        if ('person_id' not in params or
                params['person_id'] is None):
            raise ValueError("Missing the required parameter `person_id` when calling `g_et_person_person_id_images`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'person_id' in params:
            path_params['person_id'] = params['person_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/person/{person_id}/images', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20064',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def g_et_person_person_id_movie_credits(self, person_id, **kwargs):  # noqa: E501
        """Get Movie Credits  # noqa: E501

        Get the movie credits for a person.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_person_person_id_movie_credits(person_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int person_id: (required)
        :return: InlineResponse20034
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.g_et_person_person_id_movie_credits_with_http_info(person_id, **kwargs)  # noqa: E501
        else:
            (data) = self.g_et_person_person_id_movie_credits_with_http_info(person_id, **kwargs)  # noqa: E501
            return data

    def g_et_person_person_id_movie_credits_with_http_info(self, person_id, **kwargs):  # noqa: E501
        """Get Movie Credits  # noqa: E501

        Get the movie credits for a person.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_person_person_id_movie_credits_with_http_info(person_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int person_id: (required)
        :return: InlineResponse20034
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['person_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method g_et_person_person_id_movie_credits" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'person_id' is set
        if ('person_id' not in params or
                params['person_id'] is None):
            raise ValueError("Missing the required parameter `person_id` when calling `g_et_person_person_id_movie_credits`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'person_id' in params:
            path_params['person_id'] = params['person_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/person/{person_id}/movie_credits', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20034',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def g_et_person_person_id_tagged_images(self, person_id, **kwargs):  # noqa: E501
        """Get Tagged Images  # noqa: E501

        Get the images that this person has been tagged in.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_person_person_id_tagged_images(person_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int person_id: (required)
        :return: InlineResponse20083
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.g_et_person_person_id_tagged_images_with_http_info(person_id, **kwargs)  # noqa: E501
        else:
            (data) = self.g_et_person_person_id_tagged_images_with_http_info(person_id, **kwargs)  # noqa: E501
            return data

    def g_et_person_person_id_tagged_images_with_http_info(self, person_id, **kwargs):  # noqa: E501
        """Get Tagged Images  # noqa: E501

        Get the images that this person has been tagged in.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_person_person_id_tagged_images_with_http_info(person_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int person_id: (required)
        :return: InlineResponse20083
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['person_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method g_et_person_person_id_tagged_images" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'person_id' is set
        if ('person_id' not in params or
                params['person_id'] is None):
            raise ValueError("Missing the required parameter `person_id` when calling `g_et_person_person_id_tagged_images`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'person_id' in params:
            path_params['person_id'] = params['person_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/person/{person_id}/tagged_images', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20083',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def g_et_person_person_id_translations(self, person_id, **kwargs):  # noqa: E501
        """Get Translations  # noqa: E501

        Get a list of translations that have been created for a person.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_person_person_id_translations(person_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int person_id: (required)
        :return: InlineResponse20022
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.g_et_person_person_id_translations_with_http_info(person_id, **kwargs)  # noqa: E501
        else:
            (data) = self.g_et_person_person_id_translations_with_http_info(person_id, **kwargs)  # noqa: E501
            return data

    def g_et_person_person_id_translations_with_http_info(self, person_id, **kwargs):  # noqa: E501
        """Get Translations  # noqa: E501

        Get a list of translations that have been created for a person.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_person_person_id_translations_with_http_info(person_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int person_id: (required)
        :return: InlineResponse20022
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['person_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method g_et_person_person_id_translations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'person_id' is set
        if ('person_id' not in params or
                params['person_id'] is None):
            raise ValueError("Missing the required parameter `person_id` when calling `g_et_person_person_id_translations`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'person_id' in params:
            path_params['person_id'] = params['person_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/person/{person_id}/translations', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20022',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def g_et_person_person_id_tv_credits(self, person_id, **kwargs):  # noqa: E501
        """Get TV Credits  # noqa: E501

        Get the TV show credits for a person.  You can query for some extra details about the credit with the [credit method](#endpoint:xPWdEBLkvCNZSicLN).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_person_person_id_tv_credits(person_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int person_id: (required)
        :return: InlineResponse20093
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.g_et_person_person_id_tv_credits_with_http_info(person_id, **kwargs)  # noqa: E501
        else:
            (data) = self.g_et_person_person_id_tv_credits_with_http_info(person_id, **kwargs)  # noqa: E501
            return data

    def g_et_person_person_id_tv_credits_with_http_info(self, person_id, **kwargs):  # noqa: E501
        """Get TV Credits  # noqa: E501

        Get the TV show credits for a person.  You can query for some extra details about the credit with the [credit method](#endpoint:xPWdEBLkvCNZSicLN).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_person_person_id_tv_credits_with_http_info(person_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int person_id: (required)
        :return: InlineResponse20093
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['person_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method g_et_person_person_id_tv_credits" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'person_id' is set
        if ('person_id' not in params or
                params['person_id'] is None):
            raise ValueError("Missing the required parameter `person_id` when calling `g_et_person_person_id_tv_credits`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'person_id' in params:
            path_params['person_id'] = params['person_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/person/{person_id}/tv_credits', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20093',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def g_et_person_popular(self, **kwargs):  # noqa: E501
        """Get Popular  # noqa: E501

        Get the list of popular people on TMDb. This list updates daily.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_person_popular(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse20085
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.g_et_person_popular_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.g_et_person_popular_with_http_info(**kwargs)  # noqa: E501
            return data

    def g_et_person_popular_with_http_info(self, **kwargs):  # noqa: E501
        """Get Popular  # noqa: E501

        Get the list of popular people on TMDb. This list updates daily.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_person_popular_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse20085
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method g_et_person_popular" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/person/popular', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20085',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def g_et_review_review_id(self, review_id, **kwargs):  # noqa: E501
        """Get Details  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_review_review_id(review_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str review_id: (required)
        :return: InlineResponse20048
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.g_et_review_review_id_with_http_info(review_id, **kwargs)  # noqa: E501
        else:
            (data) = self.g_et_review_review_id_with_http_info(review_id, **kwargs)  # noqa: E501
            return data

    def g_et_review_review_id_with_http_info(self, review_id, **kwargs):  # noqa: E501
        """Get Details  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_review_review_id_with_http_info(review_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str review_id: (required)
        :return: InlineResponse20048
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['review_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method g_et_review_review_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'review_id' is set
        if ('review_id' not in params or
                params['review_id'] is None):
            raise ValueError("Missing the required parameter `review_id` when calling `g_et_review_review_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'review_id' in params:
            path_params['review_id'] = params['review_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/review/{review_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20048',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def g_et_search_collection(self, **kwargs):  # noqa: E501
        """Search Collections  # noqa: E501

        Search for collections.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_search_collection(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse20089
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.g_et_search_collection_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.g_et_search_collection_with_http_info(**kwargs)  # noqa: E501
            return data

    def g_et_search_collection_with_http_info(self, **kwargs):  # noqa: E501
        """Search Collections  # noqa: E501

        Search for collections.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_search_collection_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse20089
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method g_et_search_collection" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/search/collection', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20089',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def g_et_search_company(self, **kwargs):  # noqa: E501
        """Search Companies  # noqa: E501

        Search for companies.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_search_company(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse20065
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.g_et_search_company_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.g_et_search_company_with_http_info(**kwargs)  # noqa: E501
            return data

    def g_et_search_company_with_http_info(self, **kwargs):  # noqa: E501
        """Search Companies  # noqa: E501

        Search for companies.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_search_company_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse20065
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method g_et_search_company" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/search/company', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20065',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def g_et_search_keyword(self, **kwargs):  # noqa: E501
        """Search Keywords  # noqa: E501

        Search for keywords.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_search_keyword(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse20067
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.g_et_search_keyword_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.g_et_search_keyword_with_http_info(**kwargs)  # noqa: E501
            return data

    def g_et_search_keyword_with_http_info(self, **kwargs):  # noqa: E501
        """Search Keywords  # noqa: E501

        Search for keywords.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_search_keyword_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse20067
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method g_et_search_keyword" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/search/keyword', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20067',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def g_et_search_movie(self, **kwargs):  # noqa: E501
        """Search Movies  # noqa: E501

        Search for movies.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_search_movie(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int year:
        :param int primary_release_year:
        :return: InlineResponse20027
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.g_et_search_movie_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.g_et_search_movie_with_http_info(**kwargs)  # noqa: E501
            return data

    def g_et_search_movie_with_http_info(self, **kwargs):  # noqa: E501
        """Search Movies  # noqa: E501

        Search for movies.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_search_movie_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int year:
        :param int primary_release_year:
        :return: InlineResponse20027
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['year', 'primary_release_year']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method g_et_search_movie" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'year' in params:
            query_params.append(('year', params['year']))  # noqa: E501
        if 'primary_release_year' in params:
            query_params.append(('primary_release_year', params['primary_release_year']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/search/movie', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20027',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def g_et_search_multi(self, **kwargs):  # noqa: E501
        """Multi Search  # noqa: E501

        Search multiple models in a single request. Multi search currently supports searching for movies, tv shows and people in a single request.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_search_multi(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse2004
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.g_et_search_multi_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.g_et_search_multi_with_http_info(**kwargs)  # noqa: E501
            return data

    def g_et_search_multi_with_http_info(self, **kwargs):  # noqa: E501
        """Multi Search  # noqa: E501

        Search multiple models in a single request. Multi search currently supports searching for movies, tv shows and people in a single request.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_search_multi_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse2004
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method g_et_search_multi" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/search/multi', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2004',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def g_et_search_person(self, **kwargs):  # noqa: E501
        """Search People  # noqa: E501

        Search for people.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_search_person(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse20062
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.g_et_search_person_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.g_et_search_person_with_http_info(**kwargs)  # noqa: E501
            return data

    def g_et_search_person_with_http_info(self, **kwargs):  # noqa: E501
        """Search People  # noqa: E501

        Search for people.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_search_person_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse20062
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method g_et_search_person" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/search/person', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20062',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def g_et_search_tv(self, **kwargs):  # noqa: E501
        """Search TV Shows  # noqa: E501

        Search for a TV show.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_search_tv(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int first_air_date_year:
        :return: InlineResponse20024
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.g_et_search_tv_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.g_et_search_tv_with_http_info(**kwargs)  # noqa: E501
            return data

    def g_et_search_tv_with_http_info(self, **kwargs):  # noqa: E501
        """Search TV Shows  # noqa: E501

        Search for a TV show.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_search_tv_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int first_air_date_year:
        :return: InlineResponse20024
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['first_air_date_year']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method g_et_search_tv" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'first_air_date_year' in params:
            query_params.append(('first_air_date_year', params['first_air_date_year']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/search/tv', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20024',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def g_et_trending_media_type_time_window(self, media_type, time_window, **kwargs):  # noqa: E501
        """Get Trending  # noqa: E501

        Get the daily or weekly trending items. The daily trending list tracks items over the period of a day while items have a 24 hour half life. The weekly list tracks items over a 7 day period, with a 7 day half life.  #### Valid Media Types  | **Media Type** | **Description** | | - | - | | all | Include all movies, TV shows and people in the results as a global trending list. | | movie | Show the trending movies in the results. | | tv | Show the trending TV shows in the results. | | person | Show the trending people in the results. |  #### Valid Time Windows  | **Time Window** | **Description** | | - | - | | day | View the trending list for the day. | | week | View the trending list for the week. |  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_trending_media_type_time_window(media_type, time_window, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str media_type: (required)
        :param str time_window: (required)
        :return: InlineResponse20073
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.g_et_trending_media_type_time_window_with_http_info(media_type, time_window, **kwargs)  # noqa: E501
        else:
            (data) = self.g_et_trending_media_type_time_window_with_http_info(media_type, time_window, **kwargs)  # noqa: E501
            return data

    def g_et_trending_media_type_time_window_with_http_info(self, media_type, time_window, **kwargs):  # noqa: E501
        """Get Trending  # noqa: E501

        Get the daily or weekly trending items. The daily trending list tracks items over the period of a day while items have a 24 hour half life. The weekly list tracks items over a 7 day period, with a 7 day half life.  #### Valid Media Types  | **Media Type** | **Description** | | - | - | | all | Include all movies, TV shows and people in the results as a global trending list. | | movie | Show the trending movies in the results. | | tv | Show the trending TV shows in the results. | | person | Show the trending people in the results. |  #### Valid Time Windows  | **Time Window** | **Description** | | - | - | | day | View the trending list for the day. | | week | View the trending list for the week. |  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_trending_media_type_time_window_with_http_info(media_type, time_window, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str media_type: (required)
        :param str time_window: (required)
        :return: InlineResponse20073
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['media_type', 'time_window']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method g_et_trending_media_type_time_window" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'media_type' is set
        if ('media_type' not in params or
                params['media_type'] is None):
            raise ValueError("Missing the required parameter `media_type` when calling `g_et_trending_media_type_time_window`")  # noqa: E501
        # verify the required parameter 'time_window' is set
        if ('time_window' not in params or
                params['time_window'] is None):
            raise ValueError("Missing the required parameter `time_window` when calling `g_et_trending_media_type_time_window`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'media_type' in params:
            path_params['media_type'] = params['media_type']  # noqa: E501
        if 'time_window' in params:
            path_params['time_window'] = params['time_window']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/trending/{media_type}/{time_window}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20073',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def g_et_tv_airing_today(self, **kwargs):  # noqa: E501
        """Get TV Airing Today  # noqa: E501

        Get a list of TV shows that are airing today. This query is purely day based as we do not currently support airing times.  You can specify a [timezone](endpoint:KQ4CDdEoWKJYLkrhS) to offset the day calculation. Without a specified timezone, this query defaults to EST (Eastern Time UTC-05:00).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_tv_airing_today(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse20024
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.g_et_tv_airing_today_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.g_et_tv_airing_today_with_http_info(**kwargs)  # noqa: E501
            return data

    def g_et_tv_airing_today_with_http_info(self, **kwargs):  # noqa: E501
        """Get TV Airing Today  # noqa: E501

        Get a list of TV shows that are airing today. This query is purely day based as we do not currently support airing times.  You can specify a [timezone](endpoint:KQ4CDdEoWKJYLkrhS) to offset the day calculation. Without a specified timezone, this query defaults to EST (Eastern Time UTC-05:00).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_tv_airing_today_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse20024
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method g_et_tv_airing_today" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/tv/airing_today', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20024',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def g_et_tv_changes(self, **kwargs):  # noqa: E501
        """Get TV Change List  # noqa: E501

        Get a list of all of the TV show ids that have been changed in the past 24 hours.  You can query it for up to 14 days worth of changed IDs at a time with the `start_date` and `end_date` query parameters. 100 items are returned per page.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_tv_changes(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse2006
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.g_et_tv_changes_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.g_et_tv_changes_with_http_info(**kwargs)  # noqa: E501
            return data

    def g_et_tv_changes_with_http_info(self, **kwargs):  # noqa: E501
        """Get TV Change List  # noqa: E501

        Get a list of all of the TV show ids that have been changed in the past 24 hours.  You can query it for up to 14 days worth of changed IDs at a time with the `start_date` and `end_date` query parameters. 100 items are returned per page.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_tv_changes_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse2006
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method g_et_tv_changes" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/tv/changes', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2006',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def g_et_tv_episode_episode_id_changes(self, episode_id, **kwargs):  # noqa: E501
        """Get Changes  # noqa: E501

        Get the changes for a TV episode. By default only the last 24 hours are returned.  You can query up to 14 days in a single query by using the `start_date` and `end_date` query parameters.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_tv_episode_episode_id_changes(episode_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int episode_id: (required)
        :return: InlineResponse20015
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.g_et_tv_episode_episode_id_changes_with_http_info(episode_id, **kwargs)  # noqa: E501
        else:
            (data) = self.g_et_tv_episode_episode_id_changes_with_http_info(episode_id, **kwargs)  # noqa: E501
            return data

    def g_et_tv_episode_episode_id_changes_with_http_info(self, episode_id, **kwargs):  # noqa: E501
        """Get Changes  # noqa: E501

        Get the changes for a TV episode. By default only the last 24 hours are returned.  You can query up to 14 days in a single query by using the `start_date` and `end_date` query parameters.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_tv_episode_episode_id_changes_with_http_info(episode_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int episode_id: (required)
        :return: InlineResponse20015
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['episode_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method g_et_tv_episode_episode_id_changes" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'episode_id' is set
        if ('episode_id' not in params or
                params['episode_id'] is None):
            raise ValueError("Missing the required parameter `episode_id` when calling `g_et_tv_episode_episode_id_changes`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'episode_id' in params:
            path_params['episode_id'] = params['episode_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/tv/episode/{episode_id}/changes', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20015',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def g_et_tv_episode_group_id(self, id, **kwargs):  # noqa: E501
        """Get Details  # noqa: E501

        Get the details of a TV episode group. Groups support 7 different types which are enumerated as the following:  1. Original air date 2. Absolute 3. DVD 4. Digital 5. Story arc 6. Production 7. TV  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_tv_episode_group_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :return: InlineResponse20074
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.g_et_tv_episode_group_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.g_et_tv_episode_group_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def g_et_tv_episode_group_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get Details  # noqa: E501

        Get the details of a TV episode group. Groups support 7 different types which are enumerated as the following:  1. Original air date 2. Absolute 3. DVD 4. Digital 5. Story arc 6. Production 7. TV  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_tv_episode_group_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :return: InlineResponse20074
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method g_et_tv_episode_group_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `g_et_tv_episode_group_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/tv/episode_group/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20074',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def g_et_tv_latest(self, **kwargs):  # noqa: E501
        """Get Latest  # noqa: E501

        Get the most newly created TV show. This is a live response and will continuously change.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_tv_latest(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse20032
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.g_et_tv_latest_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.g_et_tv_latest_with_http_info(**kwargs)  # noqa: E501
            return data

    def g_et_tv_latest_with_http_info(self, **kwargs):  # noqa: E501
        """Get Latest  # noqa: E501

        Get the most newly created TV show. This is a live response and will continuously change.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_tv_latest_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse20032
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method g_et_tv_latest" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/tv/latest', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20032',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def g_et_tv_on_the_air(self, **kwargs):  # noqa: E501
        """Get TV On The Air  # noqa: E501

        Get a list of shows that are currently on the air.  This query looks for any TV show that has an episode with an air date in the next 7 days.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_tv_on_the_air(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse20024
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.g_et_tv_on_the_air_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.g_et_tv_on_the_air_with_http_info(**kwargs)  # noqa: E501
            return data

    def g_et_tv_on_the_air_with_http_info(self, **kwargs):  # noqa: E501
        """Get TV On The Air  # noqa: E501

        Get a list of shows that are currently on the air.  This query looks for any TV show that has an episode with an air date in the next 7 days.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_tv_on_the_air_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse20024
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method g_et_tv_on_the_air" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/tv/on_the_air', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20024',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def g_et_tv_popular(self, **kwargs):  # noqa: E501
        """Get Popular  # noqa: E501

        Get a list of the current popular TV shows on TMDb. This list updates daily.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_tv_popular(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse20024
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.g_et_tv_popular_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.g_et_tv_popular_with_http_info(**kwargs)  # noqa: E501
            return data

    def g_et_tv_popular_with_http_info(self, **kwargs):  # noqa: E501
        """Get Popular  # noqa: E501

        Get a list of the current popular TV shows on TMDb. This list updates daily.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_tv_popular_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse20024
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method g_et_tv_popular" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/tv/popular', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20024',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def g_et_tv_season_season_id_changes(self, season_id, **kwargs):  # noqa: E501
        """Get  Changes  # noqa: E501

        Get the changes for a TV season. By default only the last 24 hours are returned.  You can query up to 14 days in a single query by using the `start_date` and `end_date` query parameters.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_tv_season_season_id_changes(season_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int season_id: (required)
        :return: InlineResponse20020
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.g_et_tv_season_season_id_changes_with_http_info(season_id, **kwargs)  # noqa: E501
        else:
            (data) = self.g_et_tv_season_season_id_changes_with_http_info(season_id, **kwargs)  # noqa: E501
            return data

    def g_et_tv_season_season_id_changes_with_http_info(self, season_id, **kwargs):  # noqa: E501
        """Get  Changes  # noqa: E501

        Get the changes for a TV season. By default only the last 24 hours are returned.  You can query up to 14 days in a single query by using the `start_date` and `end_date` query parameters.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_tv_season_season_id_changes_with_http_info(season_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int season_id: (required)
        :return: InlineResponse20020
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['season_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method g_et_tv_season_season_id_changes" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'season_id' is set
        if ('season_id' not in params or
                params['season_id'] is None):
            raise ValueError("Missing the required parameter `season_id` when calling `g_et_tv_season_season_id_changes`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'season_id' in params:
            path_params['season_id'] = params['season_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/tv/season/{season_id}/changes', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20020',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def g_et_tv_top_rated(self, **kwargs):  # noqa: E501
        """Get Top Rated  # noqa: E501

        Get a list of the top rated TV shows on TMDb.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_tv_top_rated(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse20024
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.g_et_tv_top_rated_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.g_et_tv_top_rated_with_http_info(**kwargs)  # noqa: E501
            return data

    def g_et_tv_top_rated_with_http_info(self, **kwargs):  # noqa: E501
        """Get Top Rated  # noqa: E501

        Get a list of the top rated TV shows on TMDb.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_tv_top_rated_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse20024
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method g_et_tv_top_rated" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/tv/top_rated', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20024',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def g_et_tv_tv_id(self, tv_id, **kwargs):  # noqa: E501
        """Get Details  # noqa: E501

        Get the primary TV show details by id.  Supports `append_to_response`. Read more about this [here](#docTextSection:JdZq8ctmcxNqyLQjp).  #### Recent Changes  | **Date** | **Change** | | - | - | | July 17, 2018 | We now return `last_episode_to_air` and `next_episode_to_air` fields. | | March 12, 2018 | Networks return proper logos and we introduced SVG support. | | March 8, 2018 | The `seasons` field now returns the translated names and overviews. |  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_tv_tv_id(tv_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int tv_id: (required)
        :return: InlineResponse20082
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.g_et_tv_tv_id_with_http_info(tv_id, **kwargs)  # noqa: E501
        else:
            (data) = self.g_et_tv_tv_id_with_http_info(tv_id, **kwargs)  # noqa: E501
            return data

    def g_et_tv_tv_id_with_http_info(self, tv_id, **kwargs):  # noqa: E501
        """Get Details  # noqa: E501

        Get the primary TV show details by id.  Supports `append_to_response`. Read more about this [here](#docTextSection:JdZq8ctmcxNqyLQjp).  #### Recent Changes  | **Date** | **Change** | | - | - | | July 17, 2018 | We now return `last_episode_to_air` and `next_episode_to_air` fields. | | March 12, 2018 | Networks return proper logos and we introduced SVG support. | | March 8, 2018 | The `seasons` field now returns the translated names and overviews. |  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_tv_tv_id_with_http_info(tv_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int tv_id: (required)
        :return: InlineResponse20082
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['tv_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method g_et_tv_tv_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'tv_id' is set
        if ('tv_id' not in params or
                params['tv_id'] is None):
            raise ValueError("Missing the required parameter `tv_id` when calling `g_et_tv_tv_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'tv_id' in params:
            path_params['tv_id'] = params['tv_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/tv/{tv_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20082',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def g_et_tv_tv_id_account_states(self, tv_id, **kwargs):  # noqa: E501
        """Get Account States  # noqa: E501

        Grab the following account states for a session:  - TV show rating - If it belongs to your watchlist - If it belongs to your favourite list  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_tv_tv_id_account_states(tv_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int tv_id: (required)
        :param str guest_session_id:
        :param str session_id:
        :return: InlineResponse20072
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.g_et_tv_tv_id_account_states_with_http_info(tv_id, **kwargs)  # noqa: E501
        else:
            (data) = self.g_et_tv_tv_id_account_states_with_http_info(tv_id, **kwargs)  # noqa: E501
            return data

    def g_et_tv_tv_id_account_states_with_http_info(self, tv_id, **kwargs):  # noqa: E501
        """Get Account States  # noqa: E501

        Grab the following account states for a session:  - TV show rating - If it belongs to your watchlist - If it belongs to your favourite list  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_tv_tv_id_account_states_with_http_info(tv_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int tv_id: (required)
        :param str guest_session_id:
        :param str session_id:
        :return: InlineResponse20072
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['tv_id', 'guest_session_id', 'session_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method g_et_tv_tv_id_account_states" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'tv_id' is set
        if ('tv_id' not in params or
                params['tv_id'] is None):
            raise ValueError("Missing the required parameter `tv_id` when calling `g_et_tv_tv_id_account_states`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'tv_id' in params:
            path_params['tv_id'] = params['tv_id']  # noqa: E501

        query_params = []
        if 'guest_session_id' in params:
            query_params.append(('guest_session_id', params['guest_session_id']))  # noqa: E501
        if 'session_id' in params:
            query_params.append(('session_id', params['session_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/tv/{tv_id}/account_states', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20072',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def g_et_tv_tv_id_alternative_titles(self, tv_id, **kwargs):  # noqa: E501
        """Get Alternative Titles  # noqa: E501

        Returns all of the alternative titles for a TV show.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_tv_tv_id_alternative_titles(tv_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int tv_id: (required)
        :return: InlineResponse20025
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.g_et_tv_tv_id_alternative_titles_with_http_info(tv_id, **kwargs)  # noqa: E501
        else:
            (data) = self.g_et_tv_tv_id_alternative_titles_with_http_info(tv_id, **kwargs)  # noqa: E501
            return data

    def g_et_tv_tv_id_alternative_titles_with_http_info(self, tv_id, **kwargs):  # noqa: E501
        """Get Alternative Titles  # noqa: E501

        Returns all of the alternative titles for a TV show.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_tv_tv_id_alternative_titles_with_http_info(tv_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int tv_id: (required)
        :return: InlineResponse20025
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['tv_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method g_et_tv_tv_id_alternative_titles" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'tv_id' is set
        if ('tv_id' not in params or
                params['tv_id'] is None):
            raise ValueError("Missing the required parameter `tv_id` when calling `g_et_tv_tv_id_alternative_titles`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'tv_id' in params:
            path_params['tv_id'] = params['tv_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/tv/{tv_id}/alternative_titles', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20025',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def g_et_tv_tv_id_changes(self, tv_id, **kwargs):  # noqa: E501
        """Get Changes  # noqa: E501

        Get the changes for a TV show. By default only the last 24 hours are returned.  You can query up to 14 days in a single query by using the `start_date` and `end_date` query parameters.  TV show changes are different than movie changes in that there are some edits on seasons and episodes that will create a change entry at the show level. These can be found under the season and episode keys. These keys will contain a `series_id` and `episode_id`. You can use the [season changes](#endpoint:ZqhtyQbJ4YXz8RSya) and [episode changes](#endpoint:FpqrhBzgf2RJv4bHC) methods to look these up individually.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_tv_tv_id_changes(tv_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int tv_id: (required)
        :return: InlineResponse20045
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.g_et_tv_tv_id_changes_with_http_info(tv_id, **kwargs)  # noqa: E501
        else:
            (data) = self.g_et_tv_tv_id_changes_with_http_info(tv_id, **kwargs)  # noqa: E501
            return data

    def g_et_tv_tv_id_changes_with_http_info(self, tv_id, **kwargs):  # noqa: E501
        """Get Changes  # noqa: E501

        Get the changes for a TV show. By default only the last 24 hours are returned.  You can query up to 14 days in a single query by using the `start_date` and `end_date` query parameters.  TV show changes are different than movie changes in that there are some edits on seasons and episodes that will create a change entry at the show level. These can be found under the season and episode keys. These keys will contain a `series_id` and `episode_id`. You can use the [season changes](#endpoint:ZqhtyQbJ4YXz8RSya) and [episode changes](#endpoint:FpqrhBzgf2RJv4bHC) methods to look these up individually.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_tv_tv_id_changes_with_http_info(tv_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int tv_id: (required)
        :return: InlineResponse20045
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['tv_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method g_et_tv_tv_id_changes" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'tv_id' is set
        if ('tv_id' not in params or
                params['tv_id'] is None):
            raise ValueError("Missing the required parameter `tv_id` when calling `g_et_tv_tv_id_changes`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'tv_id' in params:
            path_params['tv_id'] = params['tv_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/tv/{tv_id}/changes', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20045',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def g_et_tv_tv_id_content_ratings(self, tv_id, **kwargs):  # noqa: E501
        """Get Content Ratings  # noqa: E501

        Get the list of content ratings (certifications) that have been added to a TV show.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_tv_tv_id_content_ratings(tv_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int tv_id: (required)
        :return: InlineResponse20012
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.g_et_tv_tv_id_content_ratings_with_http_info(tv_id, **kwargs)  # noqa: E501
        else:
            (data) = self.g_et_tv_tv_id_content_ratings_with_http_info(tv_id, **kwargs)  # noqa: E501
            return data

    def g_et_tv_tv_id_content_ratings_with_http_info(self, tv_id, **kwargs):  # noqa: E501
        """Get Content Ratings  # noqa: E501

        Get the list of content ratings (certifications) that have been added to a TV show.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_tv_tv_id_content_ratings_with_http_info(tv_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int tv_id: (required)
        :return: InlineResponse20012
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['tv_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method g_et_tv_tv_id_content_ratings" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'tv_id' is set
        if ('tv_id' not in params or
                params['tv_id'] is None):
            raise ValueError("Missing the required parameter `tv_id` when calling `g_et_tv_tv_id_content_ratings`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'tv_id' in params:
            path_params['tv_id'] = params['tv_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/tv/{tv_id}/content_ratings', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20012',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def g_et_tv_tv_id_credits(self, tv_id, **kwargs):  # noqa: E501
        """Get Credits  # noqa: E501

        Get the credits (cast and crew) that have been added to a TV show.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_tv_tv_id_credits(tv_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int tv_id: (required)
        :return: InlineResponse20053
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.g_et_tv_tv_id_credits_with_http_info(tv_id, **kwargs)  # noqa: E501
        else:
            (data) = self.g_et_tv_tv_id_credits_with_http_info(tv_id, **kwargs)  # noqa: E501
            return data

    def g_et_tv_tv_id_credits_with_http_info(self, tv_id, **kwargs):  # noqa: E501
        """Get Credits  # noqa: E501

        Get the credits (cast and crew) that have been added to a TV show.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_tv_tv_id_credits_with_http_info(tv_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int tv_id: (required)
        :return: InlineResponse20053
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['tv_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method g_et_tv_tv_id_credits" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'tv_id' is set
        if ('tv_id' not in params or
                params['tv_id'] is None):
            raise ValueError("Missing the required parameter `tv_id` when calling `g_et_tv_tv_id_credits`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'tv_id' in params:
            path_params['tv_id'] = params['tv_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/tv/{tv_id}/credits', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20053',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def g_et_tv_tv_id_episode_groups(self, tv_id, **kwargs):  # noqa: E501
        """Get Episode Groups  # noqa: E501

        Get all of the episode groups that have been created for a TV show. With a group ID you can call the [get TV episode group details](#endpoint:yCouThc88qs7DGHY5) method.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_tv_tv_id_episode_groups(tv_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int tv_id: (required)
        :return: InlineResponse20044
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.g_et_tv_tv_id_episode_groups_with_http_info(tv_id, **kwargs)  # noqa: E501
        else:
            (data) = self.g_et_tv_tv_id_episode_groups_with_http_info(tv_id, **kwargs)  # noqa: E501
            return data

    def g_et_tv_tv_id_episode_groups_with_http_info(self, tv_id, **kwargs):  # noqa: E501
        """Get Episode Groups  # noqa: E501

        Get all of the episode groups that have been created for a TV show. With a group ID you can call the [get TV episode group details](#endpoint:yCouThc88qs7DGHY5) method.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_tv_tv_id_episode_groups_with_http_info(tv_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int tv_id: (required)
        :return: InlineResponse20044
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['tv_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method g_et_tv_tv_id_episode_groups" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'tv_id' is set
        if ('tv_id' not in params or
                params['tv_id'] is None):
            raise ValueError("Missing the required parameter `tv_id` when calling `g_et_tv_tv_id_episode_groups`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'tv_id' in params:
            path_params['tv_id'] = params['tv_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/tv/{tv_id}/episode_groups', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20044',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def g_et_tv_tv_id_external_ids(self, tv_id, **kwargs):  # noqa: E501
        """Get External IDs  # noqa: E501

        Get the external ids for a TV show. We currently support the following external sources.  | **Media Databases** | **Social IDs** | | ------------------- | -------------- | | IMDb ID             | Facebook       | | TVDB ID             | Instagram      | | Freebase MID*       | Twitter        | | Freebase ID*        |                | | TVRage ID*          |                |  *Defunct or no longer available as a service.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_tv_tv_id_external_ids(tv_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int tv_id: (required)
        :return: InlineResponse20081
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.g_et_tv_tv_id_external_ids_with_http_info(tv_id, **kwargs)  # noqa: E501
        else:
            (data) = self.g_et_tv_tv_id_external_ids_with_http_info(tv_id, **kwargs)  # noqa: E501
            return data

    def g_et_tv_tv_id_external_ids_with_http_info(self, tv_id, **kwargs):  # noqa: E501
        """Get External IDs  # noqa: E501

        Get the external ids for a TV show. We currently support the following external sources.  | **Media Databases** | **Social IDs** | | ------------------- | -------------- | | IMDb ID             | Facebook       | | TVDB ID             | Instagram      | | Freebase MID*       | Twitter        | | Freebase ID*        |                | | TVRage ID*          |                |  *Defunct or no longer available as a service.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_tv_tv_id_external_ids_with_http_info(tv_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int tv_id: (required)
        :return: InlineResponse20081
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['tv_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method g_et_tv_tv_id_external_ids" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'tv_id' is set
        if ('tv_id' not in params or
                params['tv_id'] is None):
            raise ValueError("Missing the required parameter `tv_id` when calling `g_et_tv_tv_id_external_ids`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'tv_id' in params:
            path_params['tv_id'] = params['tv_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/tv/{tv_id}/external_ids', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20081',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def g_et_tv_tv_id_images(self, tv_id, **kwargs):  # noqa: E501
        """Get Images  # noqa: E501

        Get the images that belong to a TV show.  Querying images with a `language` parameter will filter the results. If you want to include a fallback language (especially useful for backdrops) you can use the `include_image_language` parameter. This should be a comma seperated value like so: `include_image_language=en,null`.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_tv_tv_id_images(tv_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int tv_id: (required)
        :return: InlineResponse20047
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.g_et_tv_tv_id_images_with_http_info(tv_id, **kwargs)  # noqa: E501
        else:
            (data) = self.g_et_tv_tv_id_images_with_http_info(tv_id, **kwargs)  # noqa: E501
            return data

    def g_et_tv_tv_id_images_with_http_info(self, tv_id, **kwargs):  # noqa: E501
        """Get Images  # noqa: E501

        Get the images that belong to a TV show.  Querying images with a `language` parameter will filter the results. If you want to include a fallback language (especially useful for backdrops) you can use the `include_image_language` parameter. This should be a comma seperated value like so: `include_image_language=en,null`.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_tv_tv_id_images_with_http_info(tv_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int tv_id: (required)
        :return: InlineResponse20047
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['tv_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method g_et_tv_tv_id_images" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'tv_id' is set
        if ('tv_id' not in params or
                params['tv_id'] is None):
            raise ValueError("Missing the required parameter `tv_id` when calling `g_et_tv_tv_id_images`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'tv_id' in params:
            path_params['tv_id'] = params['tv_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/tv/{tv_id}/images', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20047',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def g_et_tv_tv_id_keywords(self, tv_id, **kwargs):  # noqa: E501
        """Get Keywords  # noqa: E501

        Get the keywords that have been added to a TV show.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_tv_tv_id_keywords(tv_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int tv_id: (required)
        :return: InlineResponse20018
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.g_et_tv_tv_id_keywords_with_http_info(tv_id, **kwargs)  # noqa: E501
        else:
            (data) = self.g_et_tv_tv_id_keywords_with_http_info(tv_id, **kwargs)  # noqa: E501
            return data

    def g_et_tv_tv_id_keywords_with_http_info(self, tv_id, **kwargs):  # noqa: E501
        """Get Keywords  # noqa: E501

        Get the keywords that have been added to a TV show.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_tv_tv_id_keywords_with_http_info(tv_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int tv_id: (required)
        :return: InlineResponse20018
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['tv_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method g_et_tv_tv_id_keywords" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'tv_id' is set
        if ('tv_id' not in params or
                params['tv_id'] is None):
            raise ValueError("Missing the required parameter `tv_id` when calling `g_et_tv_tv_id_keywords`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'tv_id' in params:
            path_params['tv_id'] = params['tv_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/tv/{tv_id}/keywords', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20018',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def g_et_tv_tv_id_recommendations(self, tv_id, **kwargs):  # noqa: E501
        """Get Recommendations  # noqa: E501

        Get the list of TV show recommendations for this item.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_tv_tv_id_recommendations(tv_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int tv_id: (required)
        :return: InlineResponse20011
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.g_et_tv_tv_id_recommendations_with_http_info(tv_id, **kwargs)  # noqa: E501
        else:
            (data) = self.g_et_tv_tv_id_recommendations_with_http_info(tv_id, **kwargs)  # noqa: E501
            return data

    def g_et_tv_tv_id_recommendations_with_http_info(self, tv_id, **kwargs):  # noqa: E501
        """Get Recommendations  # noqa: E501

        Get the list of TV show recommendations for this item.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_tv_tv_id_recommendations_with_http_info(tv_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int tv_id: (required)
        :return: InlineResponse20011
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['tv_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method g_et_tv_tv_id_recommendations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'tv_id' is set
        if ('tv_id' not in params or
                params['tv_id'] is None):
            raise ValueError("Missing the required parameter `tv_id` when calling `g_et_tv_tv_id_recommendations`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'tv_id' in params:
            path_params['tv_id'] = params['tv_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/tv/{tv_id}/recommendations', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20011',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def g_et_tv_tv_id_reviews(self, tv_id, **kwargs):  # noqa: E501
        """Get Reviews  # noqa: E501

        Get the reviews for a TV show.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_tv_tv_id_reviews(tv_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int tv_id: (required)
        :return: InlineResponse20076
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.g_et_tv_tv_id_reviews_with_http_info(tv_id, **kwargs)  # noqa: E501
        else:
            (data) = self.g_et_tv_tv_id_reviews_with_http_info(tv_id, **kwargs)  # noqa: E501
            return data

    def g_et_tv_tv_id_reviews_with_http_info(self, tv_id, **kwargs):  # noqa: E501
        """Get Reviews  # noqa: E501

        Get the reviews for a TV show.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_tv_tv_id_reviews_with_http_info(tv_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int tv_id: (required)
        :return: InlineResponse20076
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['tv_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method g_et_tv_tv_id_reviews" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'tv_id' is set
        if ('tv_id' not in params or
                params['tv_id'] is None):
            raise ValueError("Missing the required parameter `tv_id` when calling `g_et_tv_tv_id_reviews`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'tv_id' in params:
            path_params['tv_id'] = params['tv_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/tv/{tv_id}/reviews', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20076',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def g_et_tv_tv_id_screened_theatrically(self, tv_id, **kwargs):  # noqa: E501
        """Get Screened Theatrically  # noqa: E501

        Get a list of seasons or episodes that have been screened in a film festival or theatre.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_tv_tv_id_screened_theatrically(tv_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int tv_id: (required)
        :return: InlineResponse20046
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.g_et_tv_tv_id_screened_theatrically_with_http_info(tv_id, **kwargs)  # noqa: E501
        else:
            (data) = self.g_et_tv_tv_id_screened_theatrically_with_http_info(tv_id, **kwargs)  # noqa: E501
            return data

    def g_et_tv_tv_id_screened_theatrically_with_http_info(self, tv_id, **kwargs):  # noqa: E501
        """Get Screened Theatrically  # noqa: E501

        Get a list of seasons or episodes that have been screened in a film festival or theatre.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_tv_tv_id_screened_theatrically_with_http_info(tv_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int tv_id: (required)
        :return: InlineResponse20046
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['tv_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method g_et_tv_tv_id_screened_theatrically" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'tv_id' is set
        if ('tv_id' not in params or
                params['tv_id'] is None):
            raise ValueError("Missing the required parameter `tv_id` when calling `g_et_tv_tv_id_screened_theatrically`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'tv_id' in params:
            path_params['tv_id'] = params['tv_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/tv/{tv_id}/screened_theatrically', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20046',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def g_et_tv_tv_id_season_season_number(self, tv_id, season_number, **kwargs):  # noqa: E501
        """Get Details  # noqa: E501

        Get the TV season details by id.  Supports `append_to_response`. Read more about this [here](#docTextSection:JdZq8ctmcxNqyLQjp).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_tv_tv_id_season_season_number(tv_id, season_number, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int tv_id: (required)
        :param int season_number: (required)
        :return: InlineResponse20095
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.g_et_tv_tv_id_season_season_number_with_http_info(tv_id, season_number, **kwargs)  # noqa: E501
        else:
            (data) = self.g_et_tv_tv_id_season_season_number_with_http_info(tv_id, season_number, **kwargs)  # noqa: E501
            return data

    def g_et_tv_tv_id_season_season_number_with_http_info(self, tv_id, season_number, **kwargs):  # noqa: E501
        """Get Details  # noqa: E501

        Get the TV season details by id.  Supports `append_to_response`. Read more about this [here](#docTextSection:JdZq8ctmcxNqyLQjp).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_tv_tv_id_season_season_number_with_http_info(tv_id, season_number, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int tv_id: (required)
        :param int season_number: (required)
        :return: InlineResponse20095
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['tv_id', 'season_number']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method g_et_tv_tv_id_season_season_number" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'tv_id' is set
        if ('tv_id' not in params or
                params['tv_id'] is None):
            raise ValueError("Missing the required parameter `tv_id` when calling `g_et_tv_tv_id_season_season_number`")  # noqa: E501
        # verify the required parameter 'season_number' is set
        if ('season_number' not in params or
                params['season_number'] is None):
            raise ValueError("Missing the required parameter `season_number` when calling `g_et_tv_tv_id_season_season_number`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'tv_id' in params:
            path_params['tv_id'] = params['tv_id']  # noqa: E501
        if 'season_number' in params:
            path_params['season_number'] = params['season_number']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/tv/{tv_id}/season/{season_number}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20095',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def g_et_tv_tv_id_season_season_number_account_states(self, tv_id, season_number, **kwargs):  # noqa: E501
        """Get Account States  # noqa: E501

        Returns all of the user ratings for the season's episodes.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_tv_tv_id_season_season_number_account_states(tv_id, season_number, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int tv_id: (required)
        :param int season_number: (required)
        :param str guest_session_id:
        :param str session_id:
        :return: InlineResponse20037
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.g_et_tv_tv_id_season_season_number_account_states_with_http_info(tv_id, season_number, **kwargs)  # noqa: E501
        else:
            (data) = self.g_et_tv_tv_id_season_season_number_account_states_with_http_info(tv_id, season_number, **kwargs)  # noqa: E501
            return data

    def g_et_tv_tv_id_season_season_number_account_states_with_http_info(self, tv_id, season_number, **kwargs):  # noqa: E501
        """Get Account States  # noqa: E501

        Returns all of the user ratings for the season's episodes.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_tv_tv_id_season_season_number_account_states_with_http_info(tv_id, season_number, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int tv_id: (required)
        :param int season_number: (required)
        :param str guest_session_id:
        :param str session_id:
        :return: InlineResponse20037
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['tv_id', 'season_number', 'guest_session_id', 'session_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method g_et_tv_tv_id_season_season_number_account_states" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'tv_id' is set
        if ('tv_id' not in params or
                params['tv_id'] is None):
            raise ValueError("Missing the required parameter `tv_id` when calling `g_et_tv_tv_id_season_season_number_account_states`")  # noqa: E501
        # verify the required parameter 'season_number' is set
        if ('season_number' not in params or
                params['season_number'] is None):
            raise ValueError("Missing the required parameter `season_number` when calling `g_et_tv_tv_id_season_season_number_account_states`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'tv_id' in params:
            path_params['tv_id'] = params['tv_id']  # noqa: E501
        if 'season_number' in params:
            path_params['season_number'] = params['season_number']  # noqa: E501

        query_params = []
        if 'guest_session_id' in params:
            query_params.append(('guest_session_id', params['guest_session_id']))  # noqa: E501
        if 'session_id' in params:
            query_params.append(('session_id', params['session_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/tv/{tv_id}/season/{season_number}/account_states', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20037',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def g_et_tv_tv_id_season_season_number_credits(self, tv_id, season_number, **kwargs):  # noqa: E501
        """Get Credits  # noqa: E501

        Get the credits for TV season.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_tv_tv_id_season_season_number_credits(tv_id, season_number, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int tv_id: (required)
        :param int season_number: (required)
        :return: InlineResponse20053
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.g_et_tv_tv_id_season_season_number_credits_with_http_info(tv_id, season_number, **kwargs)  # noqa: E501
        else:
            (data) = self.g_et_tv_tv_id_season_season_number_credits_with_http_info(tv_id, season_number, **kwargs)  # noqa: E501
            return data

    def g_et_tv_tv_id_season_season_number_credits_with_http_info(self, tv_id, season_number, **kwargs):  # noqa: E501
        """Get Credits  # noqa: E501

        Get the credits for TV season.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_tv_tv_id_season_season_number_credits_with_http_info(tv_id, season_number, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int tv_id: (required)
        :param int season_number: (required)
        :return: InlineResponse20053
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['tv_id', 'season_number']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method g_et_tv_tv_id_season_season_number_credits" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'tv_id' is set
        if ('tv_id' not in params or
                params['tv_id'] is None):
            raise ValueError("Missing the required parameter `tv_id` when calling `g_et_tv_tv_id_season_season_number_credits`")  # noqa: E501
        # verify the required parameter 'season_number' is set
        if ('season_number' not in params or
                params['season_number'] is None):
            raise ValueError("Missing the required parameter `season_number` when calling `g_et_tv_tv_id_season_season_number_credits`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'tv_id' in params:
            path_params['tv_id'] = params['tv_id']  # noqa: E501
        if 'season_number' in params:
            path_params['season_number'] = params['season_number']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/tv/{tv_id}/season/{season_number}/credits', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20053',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def g_et_tv_tv_id_season_season_number_episode_episode_number(self, tv_id, season_number, episode_number, **kwargs):  # noqa: E501
        """Get Details  # noqa: E501

        Get the TV episode details by id.  Supports `append_to_response`. Read more about this [here](#docTextSection:JdZq8ctmcxNqyLQjp).  #### Recent Changes  | **Date** | **Change** | | - | - | | June 1, 2018 | Added the [translations](#endpoint:5SFwZar3LkP99QMp7) method. |  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_tv_tv_id_season_season_number_episode_episode_number(tv_id, season_number, episode_number, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int tv_id: (required)
        :param int season_number: (required)
        :param int episode_number: (required)
        :return: InlineResponse20033
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.g_et_tv_tv_id_season_season_number_episode_episode_number_with_http_info(tv_id, season_number, episode_number, **kwargs)  # noqa: E501
        else:
            (data) = self.g_et_tv_tv_id_season_season_number_episode_episode_number_with_http_info(tv_id, season_number, episode_number, **kwargs)  # noqa: E501
            return data

    def g_et_tv_tv_id_season_season_number_episode_episode_number_with_http_info(self, tv_id, season_number, episode_number, **kwargs):  # noqa: E501
        """Get Details  # noqa: E501

        Get the TV episode details by id.  Supports `append_to_response`. Read more about this [here](#docTextSection:JdZq8ctmcxNqyLQjp).  #### Recent Changes  | **Date** | **Change** | | - | - | | June 1, 2018 | Added the [translations](#endpoint:5SFwZar3LkP99QMp7) method. |  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_tv_tv_id_season_season_number_episode_episode_number_with_http_info(tv_id, season_number, episode_number, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int tv_id: (required)
        :param int season_number: (required)
        :param int episode_number: (required)
        :return: InlineResponse20033
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['tv_id', 'season_number', 'episode_number']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method g_et_tv_tv_id_season_season_number_episode_episode_number" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'tv_id' is set
        if ('tv_id' not in params or
                params['tv_id'] is None):
            raise ValueError("Missing the required parameter `tv_id` when calling `g_et_tv_tv_id_season_season_number_episode_episode_number`")  # noqa: E501
        # verify the required parameter 'season_number' is set
        if ('season_number' not in params or
                params['season_number'] is None):
            raise ValueError("Missing the required parameter `season_number` when calling `g_et_tv_tv_id_season_season_number_episode_episode_number`")  # noqa: E501
        # verify the required parameter 'episode_number' is set
        if ('episode_number' not in params or
                params['episode_number'] is None):
            raise ValueError("Missing the required parameter `episode_number` when calling `g_et_tv_tv_id_season_season_number_episode_episode_number`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'tv_id' in params:
            path_params['tv_id'] = params['tv_id']  # noqa: E501
        if 'season_number' in params:
            path_params['season_number'] = params['season_number']  # noqa: E501
        if 'episode_number' in params:
            path_params['episode_number'] = params['episode_number']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/tv/{tv_id}/season/{season_number}/episode/{episode_number}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20033',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def g_et_tv_tv_id_season_season_number_episode_episode_number_account_states(self, tv_id, season_number, episode_number, **kwargs):  # noqa: E501
        """Get Account States  # noqa: E501

        Get your rating for a episode.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_tv_tv_id_season_season_number_episode_episode_number_account_states(tv_id, season_number, episode_number, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int tv_id: (required)
        :param int season_number: (required)
        :param int episode_number: (required)
        :param str guest_session_id:
        :param str session_id:
        :return: InlineResponse20049
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.g_et_tv_tv_id_season_season_number_episode_episode_number_account_states_with_http_info(tv_id, season_number, episode_number, **kwargs)  # noqa: E501
        else:
            (data) = self.g_et_tv_tv_id_season_season_number_episode_episode_number_account_states_with_http_info(tv_id, season_number, episode_number, **kwargs)  # noqa: E501
            return data

    def g_et_tv_tv_id_season_season_number_episode_episode_number_account_states_with_http_info(self, tv_id, season_number, episode_number, **kwargs):  # noqa: E501
        """Get Account States  # noqa: E501

        Get your rating for a episode.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_tv_tv_id_season_season_number_episode_episode_number_account_states_with_http_info(tv_id, season_number, episode_number, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int tv_id: (required)
        :param int season_number: (required)
        :param int episode_number: (required)
        :param str guest_session_id:
        :param str session_id:
        :return: InlineResponse20049
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['tv_id', 'season_number', 'episode_number', 'guest_session_id', 'session_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method g_et_tv_tv_id_season_season_number_episode_episode_number_account_states" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'tv_id' is set
        if ('tv_id' not in params or
                params['tv_id'] is None):
            raise ValueError("Missing the required parameter `tv_id` when calling `g_et_tv_tv_id_season_season_number_episode_episode_number_account_states`")  # noqa: E501
        # verify the required parameter 'season_number' is set
        if ('season_number' not in params or
                params['season_number'] is None):
            raise ValueError("Missing the required parameter `season_number` when calling `g_et_tv_tv_id_season_season_number_episode_episode_number_account_states`")  # noqa: E501
        # verify the required parameter 'episode_number' is set
        if ('episode_number' not in params or
                params['episode_number'] is None):
            raise ValueError("Missing the required parameter `episode_number` when calling `g_et_tv_tv_id_season_season_number_episode_episode_number_account_states`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'tv_id' in params:
            path_params['tv_id'] = params['tv_id']  # noqa: E501
        if 'season_number' in params:
            path_params['season_number'] = params['season_number']  # noqa: E501
        if 'episode_number' in params:
            path_params['episode_number'] = params['episode_number']  # noqa: E501

        query_params = []
        if 'guest_session_id' in params:
            query_params.append(('guest_session_id', params['guest_session_id']))  # noqa: E501
        if 'session_id' in params:
            query_params.append(('session_id', params['session_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/tv/{tv_id}/season/{season_number}/episode/{episode_number}/account_states', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20049',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def g_et_tv_tv_id_season_season_number_episode_episode_number_credits(self, tv_id, season_number, episode_number, **kwargs):  # noqa: E501
        """Get Credits  # noqa: E501

        Get the credits (cast, crew and guest stars) for a TV episode.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_tv_tv_id_season_season_number_episode_episode_number_credits(tv_id, season_number, episode_number, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int tv_id: (required)
        :param int season_number: (required)
        :param int episode_number: (required)
        :return: InlineResponse20026
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.g_et_tv_tv_id_season_season_number_episode_episode_number_credits_with_http_info(tv_id, season_number, episode_number, **kwargs)  # noqa: E501
        else:
            (data) = self.g_et_tv_tv_id_season_season_number_episode_episode_number_credits_with_http_info(tv_id, season_number, episode_number, **kwargs)  # noqa: E501
            return data

    def g_et_tv_tv_id_season_season_number_episode_episode_number_credits_with_http_info(self, tv_id, season_number, episode_number, **kwargs):  # noqa: E501
        """Get Credits  # noqa: E501

        Get the credits (cast, crew and guest stars) for a TV episode.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_tv_tv_id_season_season_number_episode_episode_number_credits_with_http_info(tv_id, season_number, episode_number, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int tv_id: (required)
        :param int season_number: (required)
        :param int episode_number: (required)
        :return: InlineResponse20026
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['tv_id', 'season_number', 'episode_number']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method g_et_tv_tv_id_season_season_number_episode_episode_number_credits" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'tv_id' is set
        if ('tv_id' not in params or
                params['tv_id'] is None):
            raise ValueError("Missing the required parameter `tv_id` when calling `g_et_tv_tv_id_season_season_number_episode_episode_number_credits`")  # noqa: E501
        # verify the required parameter 'season_number' is set
        if ('season_number' not in params or
                params['season_number'] is None):
            raise ValueError("Missing the required parameter `season_number` when calling `g_et_tv_tv_id_season_season_number_episode_episode_number_credits`")  # noqa: E501
        # verify the required parameter 'episode_number' is set
        if ('episode_number' not in params or
                params['episode_number'] is None):
            raise ValueError("Missing the required parameter `episode_number` when calling `g_et_tv_tv_id_season_season_number_episode_episode_number_credits`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'tv_id' in params:
            path_params['tv_id'] = params['tv_id']  # noqa: E501
        if 'season_number' in params:
            path_params['season_number'] = params['season_number']  # noqa: E501
        if 'episode_number' in params:
            path_params['episode_number'] = params['episode_number']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/tv/{tv_id}/season/{season_number}/episode/{episode_number}/credits', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20026',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def g_et_tv_tv_id_season_season_number_episode_episode_number_external_ids(self, tv_id, season_number, episode_number, **kwargs):  # noqa: E501
        """Get External IDs  # noqa: E501

        Get the external ids for a TV episode. We currently support the following external sources.  | **External Sources** | | -------------------- | | IMDb ID              | | TVDB ID              | | Freebase MID*        | | Freebase ID*         | | TVRage ID*           |  *Defunct or no longer available as a service.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_tv_tv_id_season_season_number_episode_episode_number_external_ids(tv_id, season_number, episode_number, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int tv_id: (required)
        :param int season_number: (required)
        :param int episode_number: (required)
        :return: InlineResponse20016
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.g_et_tv_tv_id_season_season_number_episode_episode_number_external_ids_with_http_info(tv_id, season_number, episode_number, **kwargs)  # noqa: E501
        else:
            (data) = self.g_et_tv_tv_id_season_season_number_episode_episode_number_external_ids_with_http_info(tv_id, season_number, episode_number, **kwargs)  # noqa: E501
            return data

    def g_et_tv_tv_id_season_season_number_episode_episode_number_external_ids_with_http_info(self, tv_id, season_number, episode_number, **kwargs):  # noqa: E501
        """Get External IDs  # noqa: E501

        Get the external ids for a TV episode. We currently support the following external sources.  | **External Sources** | | -------------------- | | IMDb ID              | | TVDB ID              | | Freebase MID*        | | Freebase ID*         | | TVRage ID*           |  *Defunct or no longer available as a service.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_tv_tv_id_season_season_number_episode_episode_number_external_ids_with_http_info(tv_id, season_number, episode_number, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int tv_id: (required)
        :param int season_number: (required)
        :param int episode_number: (required)
        :return: InlineResponse20016
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['tv_id', 'season_number', 'episode_number']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method g_et_tv_tv_id_season_season_number_episode_episode_number_external_ids" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'tv_id' is set
        if ('tv_id' not in params or
                params['tv_id'] is None):
            raise ValueError("Missing the required parameter `tv_id` when calling `g_et_tv_tv_id_season_season_number_episode_episode_number_external_ids`")  # noqa: E501
        # verify the required parameter 'season_number' is set
        if ('season_number' not in params or
                params['season_number'] is None):
            raise ValueError("Missing the required parameter `season_number` when calling `g_et_tv_tv_id_season_season_number_episode_episode_number_external_ids`")  # noqa: E501
        # verify the required parameter 'episode_number' is set
        if ('episode_number' not in params or
                params['episode_number'] is None):
            raise ValueError("Missing the required parameter `episode_number` when calling `g_et_tv_tv_id_season_season_number_episode_episode_number_external_ids`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'tv_id' in params:
            path_params['tv_id'] = params['tv_id']  # noqa: E501
        if 'season_number' in params:
            path_params['season_number'] = params['season_number']  # noqa: E501
        if 'episode_number' in params:
            path_params['episode_number'] = params['episode_number']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/tv/{tv_id}/season/{season_number}/episode/{episode_number}/external_ids', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20016',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def g_et_tv_tv_id_season_season_number_episode_episode_number_images(self, tv_id, season_number, episode_number, **kwargs):  # noqa: E501
        """Get Images  # noqa: E501

        Get the images that belong to a TV episode.  Querying images with a `language` parameter will filter the results. If you want to include a fallback language (especially useful for backdrops) you can use the `include_image_language` parameter. This should be a comma seperated value like so: `include_image_language=en,null`.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_tv_tv_id_season_season_number_episode_episode_number_images(tv_id, season_number, episode_number, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int tv_id: (required)
        :param int season_number: (required)
        :param int episode_number: (required)
        :return: InlineResponse20069
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.g_et_tv_tv_id_season_season_number_episode_episode_number_images_with_http_info(tv_id, season_number, episode_number, **kwargs)  # noqa: E501
        else:
            (data) = self.g_et_tv_tv_id_season_season_number_episode_episode_number_images_with_http_info(tv_id, season_number, episode_number, **kwargs)  # noqa: E501
            return data

    def g_et_tv_tv_id_season_season_number_episode_episode_number_images_with_http_info(self, tv_id, season_number, episode_number, **kwargs):  # noqa: E501
        """Get Images  # noqa: E501

        Get the images that belong to a TV episode.  Querying images with a `language` parameter will filter the results. If you want to include a fallback language (especially useful for backdrops) you can use the `include_image_language` parameter. This should be a comma seperated value like so: `include_image_language=en,null`.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_tv_tv_id_season_season_number_episode_episode_number_images_with_http_info(tv_id, season_number, episode_number, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int tv_id: (required)
        :param int season_number: (required)
        :param int episode_number: (required)
        :return: InlineResponse20069
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['tv_id', 'season_number', 'episode_number']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method g_et_tv_tv_id_season_season_number_episode_episode_number_images" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'tv_id' is set
        if ('tv_id' not in params or
                params['tv_id'] is None):
            raise ValueError("Missing the required parameter `tv_id` when calling `g_et_tv_tv_id_season_season_number_episode_episode_number_images`")  # noqa: E501
        # verify the required parameter 'season_number' is set
        if ('season_number' not in params or
                params['season_number'] is None):
            raise ValueError("Missing the required parameter `season_number` when calling `g_et_tv_tv_id_season_season_number_episode_episode_number_images`")  # noqa: E501
        # verify the required parameter 'episode_number' is set
        if ('episode_number' not in params or
                params['episode_number'] is None):
            raise ValueError("Missing the required parameter `episode_number` when calling `g_et_tv_tv_id_season_season_number_episode_episode_number_images`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'tv_id' in params:
            path_params['tv_id'] = params['tv_id']  # noqa: E501
        if 'season_number' in params:
            path_params['season_number'] = params['season_number']  # noqa: E501
        if 'episode_number' in params:
            path_params['episode_number'] = params['episode_number']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/tv/{tv_id}/season/{season_number}/episode/{episode_number}/images', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20069',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def g_et_tv_tv_id_season_season_number_episode_episode_number_translations(self, tv_id, season_number, episode_number, **kwargs):  # noqa: E501
        """Get Translations  # noqa: E501

        Get the translation data for an episode.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_tv_tv_id_season_season_number_episode_episode_number_translations(tv_id, season_number, episode_number, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int tv_id: (required)
        :param int season_number: (required)
        :param int episode_number: (required)
        :return: InlineResponse20019
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.g_et_tv_tv_id_season_season_number_episode_episode_number_translations_with_http_info(tv_id, season_number, episode_number, **kwargs)  # noqa: E501
        else:
            (data) = self.g_et_tv_tv_id_season_season_number_episode_episode_number_translations_with_http_info(tv_id, season_number, episode_number, **kwargs)  # noqa: E501
            return data

    def g_et_tv_tv_id_season_season_number_episode_episode_number_translations_with_http_info(self, tv_id, season_number, episode_number, **kwargs):  # noqa: E501
        """Get Translations  # noqa: E501

        Get the translation data for an episode.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_tv_tv_id_season_season_number_episode_episode_number_translations_with_http_info(tv_id, season_number, episode_number, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int tv_id: (required)
        :param int season_number: (required)
        :param int episode_number: (required)
        :return: InlineResponse20019
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['tv_id', 'season_number', 'episode_number']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method g_et_tv_tv_id_season_season_number_episode_episode_number_translations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'tv_id' is set
        if ('tv_id' not in params or
                params['tv_id'] is None):
            raise ValueError("Missing the required parameter `tv_id` when calling `g_et_tv_tv_id_season_season_number_episode_episode_number_translations`")  # noqa: E501
        # verify the required parameter 'season_number' is set
        if ('season_number' not in params or
                params['season_number'] is None):
            raise ValueError("Missing the required parameter `season_number` when calling `g_et_tv_tv_id_season_season_number_episode_episode_number_translations`")  # noqa: E501
        # verify the required parameter 'episode_number' is set
        if ('episode_number' not in params or
                params['episode_number'] is None):
            raise ValueError("Missing the required parameter `episode_number` when calling `g_et_tv_tv_id_season_season_number_episode_episode_number_translations`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'tv_id' in params:
            path_params['tv_id'] = params['tv_id']  # noqa: E501
        if 'season_number' in params:
            path_params['season_number'] = params['season_number']  # noqa: E501
        if 'episode_number' in params:
            path_params['episode_number'] = params['episode_number']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/tv/{tv_id}/season/{season_number}/episode/{episode_number}/translations', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20019',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def g_et_tv_tv_id_season_season_number_episode_episode_number_videos(self, tv_id, season_number, episode_number, **kwargs):  # noqa: E501
        """Get  Videos  # noqa: E501

        Get the videos that have been added to a TV episode.  #### Recent Changes  | **Date** | **Change** | | - | - | | March 23, 2019 | Vimeo was added as a video source. | | March 20, 2019 | \"Behind the Scenes\", \"Bloopers\" and \"Recap\" were added as valid video types. |  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_tv_tv_id_season_season_number_episode_episode_number_videos(tv_id, season_number, episode_number, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int tv_id: (required)
        :param int season_number: (required)
        :param int episode_number: (required)
        :return: InlineResponse20075
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.g_et_tv_tv_id_season_season_number_episode_episode_number_videos_with_http_info(tv_id, season_number, episode_number, **kwargs)  # noqa: E501
        else:
            (data) = self.g_et_tv_tv_id_season_season_number_episode_episode_number_videos_with_http_info(tv_id, season_number, episode_number, **kwargs)  # noqa: E501
            return data

    def g_et_tv_tv_id_season_season_number_episode_episode_number_videos_with_http_info(self, tv_id, season_number, episode_number, **kwargs):  # noqa: E501
        """Get  Videos  # noqa: E501

        Get the videos that have been added to a TV episode.  #### Recent Changes  | **Date** | **Change** | | - | - | | March 23, 2019 | Vimeo was added as a video source. | | March 20, 2019 | \"Behind the Scenes\", \"Bloopers\" and \"Recap\" were added as valid video types. |  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_tv_tv_id_season_season_number_episode_episode_number_videos_with_http_info(tv_id, season_number, episode_number, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int tv_id: (required)
        :param int season_number: (required)
        :param int episode_number: (required)
        :return: InlineResponse20075
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['tv_id', 'season_number', 'episode_number']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method g_et_tv_tv_id_season_season_number_episode_episode_number_videos" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'tv_id' is set
        if ('tv_id' not in params or
                params['tv_id'] is None):
            raise ValueError("Missing the required parameter `tv_id` when calling `g_et_tv_tv_id_season_season_number_episode_episode_number_videos`")  # noqa: E501
        # verify the required parameter 'season_number' is set
        if ('season_number' not in params or
                params['season_number'] is None):
            raise ValueError("Missing the required parameter `season_number` when calling `g_et_tv_tv_id_season_season_number_episode_episode_number_videos`")  # noqa: E501
        # verify the required parameter 'episode_number' is set
        if ('episode_number' not in params or
                params['episode_number'] is None):
            raise ValueError("Missing the required parameter `episode_number` when calling `g_et_tv_tv_id_season_season_number_episode_episode_number_videos`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'tv_id' in params:
            path_params['tv_id'] = params['tv_id']  # noqa: E501
        if 'season_number' in params:
            path_params['season_number'] = params['season_number']  # noqa: E501
        if 'episode_number' in params:
            path_params['episode_number'] = params['episode_number']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/tv/{tv_id}/season/{season_number}/episode/{episode_number}/videos', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20075',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def g_et_tv_tv_id_season_season_number_external_ids(self, tv_id, season_number, **kwargs):  # noqa: E501
        """Get External IDs  # noqa: E501

        Get the external ids for a TV season. We currently support the following external sources.  | **Media Databases** | | ------------------- | | TVDB ID             | | Freebase MID*       | | Freebase ID*        | | TVRage ID*          |  *Defunct or no longer available as a service.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_tv_tv_id_season_season_number_external_ids(tv_id, season_number, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int tv_id: (required)
        :param int season_number: (required)
        :return: InlineResponse20055
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.g_et_tv_tv_id_season_season_number_external_ids_with_http_info(tv_id, season_number, **kwargs)  # noqa: E501
        else:
            (data) = self.g_et_tv_tv_id_season_season_number_external_ids_with_http_info(tv_id, season_number, **kwargs)  # noqa: E501
            return data

    def g_et_tv_tv_id_season_season_number_external_ids_with_http_info(self, tv_id, season_number, **kwargs):  # noqa: E501
        """Get External IDs  # noqa: E501

        Get the external ids for a TV season. We currently support the following external sources.  | **Media Databases** | | ------------------- | | TVDB ID             | | Freebase MID*       | | Freebase ID*        | | TVRage ID*          |  *Defunct or no longer available as a service.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_tv_tv_id_season_season_number_external_ids_with_http_info(tv_id, season_number, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int tv_id: (required)
        :param int season_number: (required)
        :return: InlineResponse20055
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['tv_id', 'season_number']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method g_et_tv_tv_id_season_season_number_external_ids" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'tv_id' is set
        if ('tv_id' not in params or
                params['tv_id'] is None):
            raise ValueError("Missing the required parameter `tv_id` when calling `g_et_tv_tv_id_season_season_number_external_ids`")  # noqa: E501
        # verify the required parameter 'season_number' is set
        if ('season_number' not in params or
                params['season_number'] is None):
            raise ValueError("Missing the required parameter `season_number` when calling `g_et_tv_tv_id_season_season_number_external_ids`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'tv_id' in params:
            path_params['tv_id'] = params['tv_id']  # noqa: E501
        if 'season_number' in params:
            path_params['season_number'] = params['season_number']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/tv/{tv_id}/season/{season_number}/external_ids', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20055',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def g_et_tv_tv_id_season_season_number_images(self, tv_id, season_number, **kwargs):  # noqa: E501
        """Get Images  # noqa: E501

        Get the images that belong to a TV season.  Querying images with a `language` parameter will filter the results. If you want to include a fallback language (especially useful for backdrops) you can use the `include_image_language` parameter. This should be a comma seperated value like so: `include_image_language=en,null`.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_tv_tv_id_season_season_number_images(tv_id, season_number, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int tv_id: (required)
        :param int season_number: (required)
        :return: InlineResponse20028
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.g_et_tv_tv_id_season_season_number_images_with_http_info(tv_id, season_number, **kwargs)  # noqa: E501
        else:
            (data) = self.g_et_tv_tv_id_season_season_number_images_with_http_info(tv_id, season_number, **kwargs)  # noqa: E501
            return data

    def g_et_tv_tv_id_season_season_number_images_with_http_info(self, tv_id, season_number, **kwargs):  # noqa: E501
        """Get Images  # noqa: E501

        Get the images that belong to a TV season.  Querying images with a `language` parameter will filter the results. If you want to include a fallback language (especially useful for backdrops) you can use the `include_image_language` parameter. This should be a comma seperated value like so: `include_image_language=en,null`.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_tv_tv_id_season_season_number_images_with_http_info(tv_id, season_number, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int tv_id: (required)
        :param int season_number: (required)
        :return: InlineResponse20028
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['tv_id', 'season_number']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method g_et_tv_tv_id_season_season_number_images" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'tv_id' is set
        if ('tv_id' not in params or
                params['tv_id'] is None):
            raise ValueError("Missing the required parameter `tv_id` when calling `g_et_tv_tv_id_season_season_number_images`")  # noqa: E501
        # verify the required parameter 'season_number' is set
        if ('season_number' not in params or
                params['season_number'] is None):
            raise ValueError("Missing the required parameter `season_number` when calling `g_et_tv_tv_id_season_season_number_images`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'tv_id' in params:
            path_params['tv_id'] = params['tv_id']  # noqa: E501
        if 'season_number' in params:
            path_params['season_number'] = params['season_number']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/tv/{tv_id}/season/{season_number}/images', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20028',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def g_et_tv_tv_id_season_season_number_videos(self, tv_id, season_number, **kwargs):  # noqa: E501
        """Get Videos  # noqa: E501

        Get the videos that have been added to a TV season.  #### Recent Changes  | **Date** | **Change** | | - | - | | March 23, 2019 | Vimeo was added as a video source. | | March 20, 2019 | \"Behind the Scenes\" and \"Bloopers\" and \"Recap\" were added as valid video types. |  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_tv_tv_id_season_season_number_videos(tv_id, season_number, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int tv_id: (required)
        :param int season_number: (required)
        :return: InlineResponse20075
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.g_et_tv_tv_id_season_season_number_videos_with_http_info(tv_id, season_number, **kwargs)  # noqa: E501
        else:
            (data) = self.g_et_tv_tv_id_season_season_number_videos_with_http_info(tv_id, season_number, **kwargs)  # noqa: E501
            return data

    def g_et_tv_tv_id_season_season_number_videos_with_http_info(self, tv_id, season_number, **kwargs):  # noqa: E501
        """Get Videos  # noqa: E501

        Get the videos that have been added to a TV season.  #### Recent Changes  | **Date** | **Change** | | - | - | | March 23, 2019 | Vimeo was added as a video source. | | March 20, 2019 | \"Behind the Scenes\" and \"Bloopers\" and \"Recap\" were added as valid video types. |  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_tv_tv_id_season_season_number_videos_with_http_info(tv_id, season_number, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int tv_id: (required)
        :param int season_number: (required)
        :return: InlineResponse20075
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['tv_id', 'season_number']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method g_et_tv_tv_id_season_season_number_videos" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'tv_id' is set
        if ('tv_id' not in params or
                params['tv_id'] is None):
            raise ValueError("Missing the required parameter `tv_id` when calling `g_et_tv_tv_id_season_season_number_videos`")  # noqa: E501
        # verify the required parameter 'season_number' is set
        if ('season_number' not in params or
                params['season_number'] is None):
            raise ValueError("Missing the required parameter `season_number` when calling `g_et_tv_tv_id_season_season_number_videos`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'tv_id' in params:
            path_params['tv_id'] = params['tv_id']  # noqa: E501
        if 'season_number' in params:
            path_params['season_number'] = params['season_number']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/tv/{tv_id}/season/{season_number}/videos', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20075',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def g_et_tv_tv_id_similar(self, tv_id, **kwargs):  # noqa: E501
        """Get Similar TV Shows  # noqa: E501

        Get a list of similar TV shows. These items are assembled by looking at keywords and genres.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_tv_tv_id_similar(tv_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int tv_id: (required)
        :return: InlineResponse20011
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.g_et_tv_tv_id_similar_with_http_info(tv_id, **kwargs)  # noqa: E501
        else:
            (data) = self.g_et_tv_tv_id_similar_with_http_info(tv_id, **kwargs)  # noqa: E501
            return data

    def g_et_tv_tv_id_similar_with_http_info(self, tv_id, **kwargs):  # noqa: E501
        """Get Similar TV Shows  # noqa: E501

        Get a list of similar TV shows. These items are assembled by looking at keywords and genres.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_tv_tv_id_similar_with_http_info(tv_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int tv_id: (required)
        :return: InlineResponse20011
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['tv_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method g_et_tv_tv_id_similar" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'tv_id' is set
        if ('tv_id' not in params or
                params['tv_id'] is None):
            raise ValueError("Missing the required parameter `tv_id` when calling `g_et_tv_tv_id_similar`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'tv_id' in params:
            path_params['tv_id'] = params['tv_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/tv/{tv_id}/similar', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20011',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def g_et_tv_tv_id_translations(self, tv_id, **kwargs):  # noqa: E501
        """Get Translations  # noqa: E501

        Get a list of the translations that exist for a TV show.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_tv_tv_id_translations(tv_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int tv_id: (required)
        :return: InlineResponse20042
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.g_et_tv_tv_id_translations_with_http_info(tv_id, **kwargs)  # noqa: E501
        else:
            (data) = self.g_et_tv_tv_id_translations_with_http_info(tv_id, **kwargs)  # noqa: E501
            return data

    def g_et_tv_tv_id_translations_with_http_info(self, tv_id, **kwargs):  # noqa: E501
        """Get Translations  # noqa: E501

        Get a list of the translations that exist for a TV show.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_tv_tv_id_translations_with_http_info(tv_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int tv_id: (required)
        :return: InlineResponse20042
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['tv_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method g_et_tv_tv_id_translations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'tv_id' is set
        if ('tv_id' not in params or
                params['tv_id'] is None):
            raise ValueError("Missing the required parameter `tv_id` when calling `g_et_tv_tv_id_translations`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'tv_id' in params:
            path_params['tv_id'] = params['tv_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/tv/{tv_id}/translations', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20042',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def g_et_tv_tv_id_videos(self, tv_id, **kwargs):  # noqa: E501
        """Get Videos  # noqa: E501

        Get the videos that have been added to a TV show.  #### Recent Changes  | **Date** | **Change** | | - | - | | March 23, 2019 | Vimeo was added as a video source. | | March 20, 2019 | \"Behind the Scenes\" and \"Bloopers\" were added as valid video types. |  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_tv_tv_id_videos(tv_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int tv_id: (required)
        :return: InlineResponse20052
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.g_et_tv_tv_id_videos_with_http_info(tv_id, **kwargs)  # noqa: E501
        else:
            (data) = self.g_et_tv_tv_id_videos_with_http_info(tv_id, **kwargs)  # noqa: E501
            return data

    def g_et_tv_tv_id_videos_with_http_info(self, tv_id, **kwargs):  # noqa: E501
        """Get Videos  # noqa: E501

        Get the videos that have been added to a TV show.  #### Recent Changes  | **Date** | **Change** | | - | - | | March 23, 2019 | Vimeo was added as a video source. | | March 20, 2019 | \"Behind the Scenes\" and \"Bloopers\" were added as valid video types. |  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.g_et_tv_tv_id_videos_with_http_info(tv_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int tv_id: (required)
        :return: InlineResponse20052
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['tv_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method g_et_tv_tv_id_videos" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'tv_id' is set
        if ('tv_id' not in params or
                params['tv_id'] is None):
            raise ValueError("Missing the required parameter `tv_id` when calling `g_et_tv_tv_id_videos`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'tv_id' in params:
            path_params['tv_id'] = params['tv_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/tv/{tv_id}/videos', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20052',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def p_ost_account_account_id_favorite(self, content_type, session_id, account_id, **kwargs):  # noqa: E501
        """Mark as Favorite  # noqa: E501

        This method allows you to mark a movie or TV show as a favorite item.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.p_ost_account_account_id_favorite(content_type, session_id, account_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str content_type: (required)
        :param str session_id: (required)
        :param int account_id: (required)
        :param Body8 body:
        :return: InlineResponse401
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.p_ost_account_account_id_favorite_with_http_info(content_type, session_id, account_id, **kwargs)  # noqa: E501
        else:
            (data) = self.p_ost_account_account_id_favorite_with_http_info(content_type, session_id, account_id, **kwargs)  # noqa: E501
            return data

    def p_ost_account_account_id_favorite_with_http_info(self, content_type, session_id, account_id, **kwargs):  # noqa: E501
        """Mark as Favorite  # noqa: E501

        This method allows you to mark a movie or TV show as a favorite item.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.p_ost_account_account_id_favorite_with_http_info(content_type, session_id, account_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str content_type: (required)
        :param str session_id: (required)
        :param int account_id: (required)
        :param Body8 body:
        :return: InlineResponse401
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['content_type', 'session_id', 'account_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method p_ost_account_account_id_favorite" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'content_type' is set
        if ('content_type' not in params or
                params['content_type'] is None):
            raise ValueError("Missing the required parameter `content_type` when calling `p_ost_account_account_id_favorite`")  # noqa: E501
        # verify the required parameter 'session_id' is set
        if ('session_id' not in params or
                params['session_id'] is None):
            raise ValueError("Missing the required parameter `session_id` when calling `p_ost_account_account_id_favorite`")  # noqa: E501
        # verify the required parameter 'account_id' is set
        if ('account_id' not in params or
                params['account_id'] is None):
            raise ValueError("Missing the required parameter `account_id` when calling `p_ost_account_account_id_favorite`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'account_id' in params:
            path_params['account_id'] = params['account_id']  # noqa: E501

        query_params = []
        if 'session_id' in params:
            query_params.append(('session_id', params['session_id']))  # noqa: E501

        header_params = {}
        if 'content_type' in params:
            header_params['Content-Type'] = params['content_type']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/account/{account_id}/favorite', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse401',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def p_ost_account_account_id_watchlist(self, content_type, session_id, account_id, **kwargs):  # noqa: E501
        """Add to Watchlist  # noqa: E501

        Add a movie or TV show to your watchlist.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.p_ost_account_account_id_watchlist(content_type, session_id, account_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str content_type: (required)
        :param str session_id: (required)
        :param int account_id: (required)
        :param Body5 body:
        :return: InlineResponse401
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.p_ost_account_account_id_watchlist_with_http_info(content_type, session_id, account_id, **kwargs)  # noqa: E501
        else:
            (data) = self.p_ost_account_account_id_watchlist_with_http_info(content_type, session_id, account_id, **kwargs)  # noqa: E501
            return data

    def p_ost_account_account_id_watchlist_with_http_info(self, content_type, session_id, account_id, **kwargs):  # noqa: E501
        """Add to Watchlist  # noqa: E501

        Add a movie or TV show to your watchlist.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.p_ost_account_account_id_watchlist_with_http_info(content_type, session_id, account_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str content_type: (required)
        :param str session_id: (required)
        :param int account_id: (required)
        :param Body5 body:
        :return: InlineResponse401
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['content_type', 'session_id', 'account_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method p_ost_account_account_id_watchlist" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'content_type' is set
        if ('content_type' not in params or
                params['content_type'] is None):
            raise ValueError("Missing the required parameter `content_type` when calling `p_ost_account_account_id_watchlist`")  # noqa: E501
        # verify the required parameter 'session_id' is set
        if ('session_id' not in params or
                params['session_id'] is None):
            raise ValueError("Missing the required parameter `session_id` when calling `p_ost_account_account_id_watchlist`")  # noqa: E501
        # verify the required parameter 'account_id' is set
        if ('account_id' not in params or
                params['account_id'] is None):
            raise ValueError("Missing the required parameter `account_id` when calling `p_ost_account_account_id_watchlist`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'account_id' in params:
            path_params['account_id'] = params['account_id']  # noqa: E501

        query_params = []
        if 'session_id' in params:
            query_params.append(('session_id', params['session_id']))  # noqa: E501

        header_params = {}
        if 'content_type' in params:
            header_params['Content-Type'] = params['content_type']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/account/{account_id}/watchlist', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse401',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def p_ost_authentication_session_convert4(self, **kwargs):  # noqa: E501
        """Create Session (from v4 access token)  # noqa: E501

        Use this method to create a v3 session ID if you already have a valid v4 access token. The v4 token needs to be authenticated by the user. Your standard \"read token\" will not validate to create a session ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.p_ost_authentication_session_convert4(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Body body:
        :return: InlineResponse200
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.p_ost_authentication_session_convert4_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.p_ost_authentication_session_convert4_with_http_info(**kwargs)  # noqa: E501
            return data

    def p_ost_authentication_session_convert4_with_http_info(self, **kwargs):  # noqa: E501
        """Create Session (from v4 access token)  # noqa: E501

        Use this method to create a v3 session ID if you already have a valid v4 access token. The v4 token needs to be authenticated by the user. Your standard \"read token\" will not validate to create a session ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.p_ost_authentication_session_convert4_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Body body:
        :return: InlineResponse200
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method p_ost_authentication_session_convert4" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/authentication/session/convert/4', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse200',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def p_ost_authentication_session_new(self, **kwargs):  # noqa: E501
        """Create Session  # noqa: E501

        You can use this method to create a fully valid session ID once a user has validated the request token. More information about how this works can be found [here](#docTextSection:NSZtgz7zptsiLYxXZ).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.p_ost_authentication_session_new(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Body1 body:
        :return: InlineResponse200
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.p_ost_authentication_session_new_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.p_ost_authentication_session_new_with_http_info(**kwargs)  # noqa: E501
            return data

    def p_ost_authentication_session_new_with_http_info(self, **kwargs):  # noqa: E501
        """Create Session  # noqa: E501

        You can use this method to create a fully valid session ID once a user has validated the request token. More information about how this works can be found [here](#docTextSection:NSZtgz7zptsiLYxXZ).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.p_ost_authentication_session_new_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Body1 body:
        :return: InlineResponse200
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method p_ost_authentication_session_new" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/authentication/session/new', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse200',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def p_ost_authentication_token_validate_with_login(self, **kwargs):  # noqa: E501
        """Create Session With Login  # noqa: E501

        This method allows an application to validate a request token by entering a username and password.  Not all applications have access to a web view so this can be used as a substitute.  Please note, the preferred method of validating a request token is to have a user authenticate the request via the TMDb website. You can read about that method [here](#docTextSection:NSZtgz7zptsiLYxXZ).  If you decide to use this method please **use HTTPS**.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.p_ost_authentication_token_validate_with_login(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Body9 body:
        :return: InlineResponse20030
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.p_ost_authentication_token_validate_with_login_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.p_ost_authentication_token_validate_with_login_with_http_info(**kwargs)  # noqa: E501
            return data

    def p_ost_authentication_token_validate_with_login_with_http_info(self, **kwargs):  # noqa: E501
        """Create Session With Login  # noqa: E501

        This method allows an application to validate a request token by entering a username and password.  Not all applications have access to a web view so this can be used as a substitute.  Please note, the preferred method of validating a request token is to have a user authenticate the request via the TMDb website. You can read about that method [here](#docTextSection:NSZtgz7zptsiLYxXZ).  If you decide to use this method please **use HTTPS**.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.p_ost_authentication_token_validate_with_login_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Body9 body:
        :return: InlineResponse20030
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method p_ost_authentication_token_validate_with_login" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/authentication/token/validate_with_login', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20030',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def p_ost_list(self, content_type, session_id, **kwargs):  # noqa: E501
        """Create List  # noqa: E501

        Create a list.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.p_ost_list(content_type, session_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str content_type: (required)
        :param str session_id: (required)
        :param Body2 body:
        :return: InlineResponse201
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.p_ost_list_with_http_info(content_type, session_id, **kwargs)  # noqa: E501
        else:
            (data) = self.p_ost_list_with_http_info(content_type, session_id, **kwargs)  # noqa: E501
            return data

    def p_ost_list_with_http_info(self, content_type, session_id, **kwargs):  # noqa: E501
        """Create List  # noqa: E501

        Create a list.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.p_ost_list_with_http_info(content_type, session_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str content_type: (required)
        :param str session_id: (required)
        :param Body2 body:
        :return: InlineResponse201
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['content_type', 'session_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method p_ost_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'content_type' is set
        if ('content_type' not in params or
                params['content_type'] is None):
            raise ValueError("Missing the required parameter `content_type` when calling `p_ost_list`")  # noqa: E501
        # verify the required parameter 'session_id' is set
        if ('session_id' not in params or
                params['session_id'] is None):
            raise ValueError("Missing the required parameter `session_id` when calling `p_ost_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'session_id' in params:
            query_params.append(('session_id', params['session_id']))  # noqa: E501

        header_params = {}
        if 'content_type' in params:
            header_params['Content-Type'] = params['content_type']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/list', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse201',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def p_ost_list_list_id_add_item(self, content_type, session_id, list_id, **kwargs):  # noqa: E501
        """Add Movie  # noqa: E501

        Add a movie to a list.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.p_ost_list_list_id_add_item(content_type, session_id, list_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str content_type: (required)
        :param str session_id: (required)
        :param str list_id: (required)
        :param Body4 body:
        :return: InlineResponse401
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.p_ost_list_list_id_add_item_with_http_info(content_type, session_id, list_id, **kwargs)  # noqa: E501
        else:
            (data) = self.p_ost_list_list_id_add_item_with_http_info(content_type, session_id, list_id, **kwargs)  # noqa: E501
            return data

    def p_ost_list_list_id_add_item_with_http_info(self, content_type, session_id, list_id, **kwargs):  # noqa: E501
        """Add Movie  # noqa: E501

        Add a movie to a list.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.p_ost_list_list_id_add_item_with_http_info(content_type, session_id, list_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str content_type: (required)
        :param str session_id: (required)
        :param str list_id: (required)
        :param Body4 body:
        :return: InlineResponse401
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['content_type', 'session_id', 'list_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method p_ost_list_list_id_add_item" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'content_type' is set
        if ('content_type' not in params or
                params['content_type'] is None):
            raise ValueError("Missing the required parameter `content_type` when calling `p_ost_list_list_id_add_item`")  # noqa: E501
        # verify the required parameter 'session_id' is set
        if ('session_id' not in params or
                params['session_id'] is None):
            raise ValueError("Missing the required parameter `session_id` when calling `p_ost_list_list_id_add_item`")  # noqa: E501
        # verify the required parameter 'list_id' is set
        if ('list_id' not in params or
                params['list_id'] is None):
            raise ValueError("Missing the required parameter `list_id` when calling `p_ost_list_list_id_add_item`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'list_id' in params:
            path_params['list_id'] = params['list_id']  # noqa: E501

        query_params = []
        if 'session_id' in params:
            query_params.append(('session_id', params['session_id']))  # noqa: E501

        header_params = {}
        if 'content_type' in params:
            header_params['Content-Type'] = params['content_type']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/list/{list_id}/add_item', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse401',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def p_ost_list_list_id_clear(self, list_id, confirm, session_id, **kwargs):  # noqa: E501
        """Clear List  # noqa: E501

        Clear all of the items from a list.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.p_ost_list_list_id_clear(list_id, confirm, session_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str list_id: (required)
        :param bool confirm: (required)
        :param str session_id: (required)
        :return: InlineResponse401
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.p_ost_list_list_id_clear_with_http_info(list_id, confirm, session_id, **kwargs)  # noqa: E501
        else:
            (data) = self.p_ost_list_list_id_clear_with_http_info(list_id, confirm, session_id, **kwargs)  # noqa: E501
            return data

    def p_ost_list_list_id_clear_with_http_info(self, list_id, confirm, session_id, **kwargs):  # noqa: E501
        """Clear List  # noqa: E501

        Clear all of the items from a list.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.p_ost_list_list_id_clear_with_http_info(list_id, confirm, session_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str list_id: (required)
        :param bool confirm: (required)
        :param str session_id: (required)
        :return: InlineResponse401
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['list_id', 'confirm', 'session_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method p_ost_list_list_id_clear" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'list_id' is set
        if ('list_id' not in params or
                params['list_id'] is None):
            raise ValueError("Missing the required parameter `list_id` when calling `p_ost_list_list_id_clear`")  # noqa: E501
        # verify the required parameter 'confirm' is set
        if ('confirm' not in params or
                params['confirm'] is None):
            raise ValueError("Missing the required parameter `confirm` when calling `p_ost_list_list_id_clear`")  # noqa: E501
        # verify the required parameter 'session_id' is set
        if ('session_id' not in params or
                params['session_id'] is None):
            raise ValueError("Missing the required parameter `session_id` when calling `p_ost_list_list_id_clear`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'list_id' in params:
            path_params['list_id'] = params['list_id']  # noqa: E501

        query_params = []
        if 'confirm' in params:
            query_params.append(('confirm', params['confirm']))  # noqa: E501
        if 'session_id' in params:
            query_params.append(('session_id', params['session_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/list/{list_id}/clear', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse401',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def p_ost_list_list_id_remove_item(self, content_type, session_id, list_id, **kwargs):  # noqa: E501
        """Remove Movie  # noqa: E501

        Remove a movie from a list.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.p_ost_list_list_id_remove_item(content_type, session_id, list_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str content_type: (required)
        :param str session_id: (required)
        :param str list_id: (required)
        :param Body6 body:
        :return: InlineResponse401
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.p_ost_list_list_id_remove_item_with_http_info(content_type, session_id, list_id, **kwargs)  # noqa: E501
        else:
            (data) = self.p_ost_list_list_id_remove_item_with_http_info(content_type, session_id, list_id, **kwargs)  # noqa: E501
            return data

    def p_ost_list_list_id_remove_item_with_http_info(self, content_type, session_id, list_id, **kwargs):  # noqa: E501
        """Remove Movie  # noqa: E501

        Remove a movie from a list.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.p_ost_list_list_id_remove_item_with_http_info(content_type, session_id, list_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str content_type: (required)
        :param str session_id: (required)
        :param str list_id: (required)
        :param Body6 body:
        :return: InlineResponse401
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['content_type', 'session_id', 'list_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method p_ost_list_list_id_remove_item" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'content_type' is set
        if ('content_type' not in params or
                params['content_type'] is None):
            raise ValueError("Missing the required parameter `content_type` when calling `p_ost_list_list_id_remove_item`")  # noqa: E501
        # verify the required parameter 'session_id' is set
        if ('session_id' not in params or
                params['session_id'] is None):
            raise ValueError("Missing the required parameter `session_id` when calling `p_ost_list_list_id_remove_item`")  # noqa: E501
        # verify the required parameter 'list_id' is set
        if ('list_id' not in params or
                params['list_id'] is None):
            raise ValueError("Missing the required parameter `list_id` when calling `p_ost_list_list_id_remove_item`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'list_id' in params:
            path_params['list_id'] = params['list_id']  # noqa: E501

        query_params = []
        if 'session_id' in params:
            query_params.append(('session_id', params['session_id']))  # noqa: E501

        header_params = {}
        if 'content_type' in params:
            header_params['Content-Type'] = params['content_type']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/list/{list_id}/remove_item', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse401',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def p_ost_movie_movie_id_rating(self, content_type, movie_id, **kwargs):  # noqa: E501
        """Rate Movie  # noqa: E501

        Rate a movie.  A valid session or guest session ID is required. You can read more about how this works [here](#docTextSection:NSZtgz7zptsiLYxXZ).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.p_ost_movie_movie_id_rating(content_type, movie_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str content_type: (required)
        :param int movie_id: (required)
        :param Body3 body:
        :param str guest_session_id:
        :param str session_id:
        :return: InlineResponse401
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.p_ost_movie_movie_id_rating_with_http_info(content_type, movie_id, **kwargs)  # noqa: E501
        else:
            (data) = self.p_ost_movie_movie_id_rating_with_http_info(content_type, movie_id, **kwargs)  # noqa: E501
            return data

    def p_ost_movie_movie_id_rating_with_http_info(self, content_type, movie_id, **kwargs):  # noqa: E501
        """Rate Movie  # noqa: E501

        Rate a movie.  A valid session or guest session ID is required. You can read more about how this works [here](#docTextSection:NSZtgz7zptsiLYxXZ).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.p_ost_movie_movie_id_rating_with_http_info(content_type, movie_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str content_type: (required)
        :param int movie_id: (required)
        :param Body3 body:
        :param str guest_session_id:
        :param str session_id:
        :return: InlineResponse401
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['content_type', 'movie_id', 'body', 'guest_session_id', 'session_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method p_ost_movie_movie_id_rating" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'content_type' is set
        if ('content_type' not in params or
                params['content_type'] is None):
            raise ValueError("Missing the required parameter `content_type` when calling `p_ost_movie_movie_id_rating`")  # noqa: E501
        # verify the required parameter 'movie_id' is set
        if ('movie_id' not in params or
                params['movie_id'] is None):
            raise ValueError("Missing the required parameter `movie_id` when calling `p_ost_movie_movie_id_rating`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'movie_id' in params:
            path_params['movie_id'] = params['movie_id']  # noqa: E501

        query_params = []
        if 'guest_session_id' in params:
            query_params.append(('guest_session_id', params['guest_session_id']))  # noqa: E501
        if 'session_id' in params:
            query_params.append(('session_id', params['session_id']))  # noqa: E501

        header_params = {}
        if 'content_type' in params:
            header_params['Content-Type'] = params['content_type']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/movie/{movie_id}/rating', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse401',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def p_ost_tv_tv_id_rating(self, content_type, tv_id, **kwargs):  # noqa: E501
        """Rate TV Show  # noqa: E501

        Rate a TV show.  A valid session or guest session ID is required. You can read more about how this works [here](#docTextSection:NSZtgz7zptsiLYxXZ).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.p_ost_tv_tv_id_rating(content_type, tv_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str content_type: (required)
        :param int tv_id: (required)
        :param object body:
        :param str guest_session_id:
        :param str session_id:
        :return: InlineResponse401
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.p_ost_tv_tv_id_rating_with_http_info(content_type, tv_id, **kwargs)  # noqa: E501
        else:
            (data) = self.p_ost_tv_tv_id_rating_with_http_info(content_type, tv_id, **kwargs)  # noqa: E501
            return data

    def p_ost_tv_tv_id_rating_with_http_info(self, content_type, tv_id, **kwargs):  # noqa: E501
        """Rate TV Show  # noqa: E501

        Rate a TV show.  A valid session or guest session ID is required. You can read more about how this works [here](#docTextSection:NSZtgz7zptsiLYxXZ).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.p_ost_tv_tv_id_rating_with_http_info(content_type, tv_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str content_type: (required)
        :param int tv_id: (required)
        :param object body:
        :param str guest_session_id:
        :param str session_id:
        :return: InlineResponse401
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['content_type', 'tv_id', 'body', 'guest_session_id', 'session_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method p_ost_tv_tv_id_rating" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'content_type' is set
        if ('content_type' not in params or
                params['content_type'] is None):
            raise ValueError("Missing the required parameter `content_type` when calling `p_ost_tv_tv_id_rating`")  # noqa: E501
        # verify the required parameter 'tv_id' is set
        if ('tv_id' not in params or
                params['tv_id'] is None):
            raise ValueError("Missing the required parameter `tv_id` when calling `p_ost_tv_tv_id_rating`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'tv_id' in params:
            path_params['tv_id'] = params['tv_id']  # noqa: E501

        query_params = []
        if 'guest_session_id' in params:
            query_params.append(('guest_session_id', params['guest_session_id']))  # noqa: E501
        if 'session_id' in params:
            query_params.append(('session_id', params['session_id']))  # noqa: E501

        header_params = {}
        if 'content_type' in params:
            header_params['Content-Type'] = params['content_type']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/tv/{tv_id}/rating', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse401',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def p_ost_tv_tv_id_season_season_number_episode_episode_number_rating(self, content_type, tv_id, season_number, episode_number, **kwargs):  # noqa: E501
        """Rate TV Episode  # noqa: E501

        Rate a TV episode.  A valid session or guest session ID is required. You can read more about how this works [here](#docTextSection:NSZtgz7zptsiLYxXZ).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.p_ost_tv_tv_id_season_season_number_episode_episode_number_rating(content_type, tv_id, season_number, episode_number, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str content_type: (required)
        :param int tv_id: (required)
        :param int season_number: (required)
        :param int episode_number: (required)
        :param object body:
        :param str guest_session_id:
        :param str session_id:
        :return: InlineResponse401
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.p_ost_tv_tv_id_season_season_number_episode_episode_number_rating_with_http_info(content_type, tv_id, season_number, episode_number, **kwargs)  # noqa: E501
        else:
            (data) = self.p_ost_tv_tv_id_season_season_number_episode_episode_number_rating_with_http_info(content_type, tv_id, season_number, episode_number, **kwargs)  # noqa: E501
            return data

    def p_ost_tv_tv_id_season_season_number_episode_episode_number_rating_with_http_info(self, content_type, tv_id, season_number, episode_number, **kwargs):  # noqa: E501
        """Rate TV Episode  # noqa: E501

        Rate a TV episode.  A valid session or guest session ID is required. You can read more about how this works [here](#docTextSection:NSZtgz7zptsiLYxXZ).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.p_ost_tv_tv_id_season_season_number_episode_episode_number_rating_with_http_info(content_type, tv_id, season_number, episode_number, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str content_type: (required)
        :param int tv_id: (required)
        :param int season_number: (required)
        :param int episode_number: (required)
        :param object body:
        :param str guest_session_id:
        :param str session_id:
        :return: InlineResponse401
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['content_type', 'tv_id', 'season_number', 'episode_number', 'body', 'guest_session_id', 'session_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method p_ost_tv_tv_id_season_season_number_episode_episode_number_rating" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'content_type' is set
        if ('content_type' not in params or
                params['content_type'] is None):
            raise ValueError("Missing the required parameter `content_type` when calling `p_ost_tv_tv_id_season_season_number_episode_episode_number_rating`")  # noqa: E501
        # verify the required parameter 'tv_id' is set
        if ('tv_id' not in params or
                params['tv_id'] is None):
            raise ValueError("Missing the required parameter `tv_id` when calling `p_ost_tv_tv_id_season_season_number_episode_episode_number_rating`")  # noqa: E501
        # verify the required parameter 'season_number' is set
        if ('season_number' not in params or
                params['season_number'] is None):
            raise ValueError("Missing the required parameter `season_number` when calling `p_ost_tv_tv_id_season_season_number_episode_episode_number_rating`")  # noqa: E501
        # verify the required parameter 'episode_number' is set
        if ('episode_number' not in params or
                params['episode_number'] is None):
            raise ValueError("Missing the required parameter `episode_number` when calling `p_ost_tv_tv_id_season_season_number_episode_episode_number_rating`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'tv_id' in params:
            path_params['tv_id'] = params['tv_id']  # noqa: E501
        if 'season_number' in params:
            path_params['season_number'] = params['season_number']  # noqa: E501
        if 'episode_number' in params:
            path_params['episode_number'] = params['episode_number']  # noqa: E501

        query_params = []
        if 'guest_session_id' in params:
            query_params.append(('guest_session_id', params['guest_session_id']))  # noqa: E501
        if 'session_id' in params:
            query_params.append(('session_id', params['session_id']))  # noqa: E501

        header_params = {}
        if 'content_type' in params:
            header_params['Content-Type'] = params['content_type']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/tv/{tv_id}/season/{season_number}/episode/{episode_number}/rating', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse401',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
